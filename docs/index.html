<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta
name="viewport"
content="width=device-width, initial-scale=1.0"
>
<title>How to Serve a React Frontend with Express</title>
<link rel="stylesheet" href="../public/styles.css">
<link rel="stylesheet" href="../public/media-queries.css">
<link rel="stylesheet" href="../public/prism/prism.css">

<script defer src="../public/prism/prism.js"></script>
<script defer src="../public/storage.js"></script>
<script defer src="../public/script.js"></script>
</head>

<body>
<main id="main">
<header>
<a href="https://MERNCraft.github.io"><img src="../public/svg/home.svg" alt="home"></a>
<h1>How to Serve a React Frontend with Express</h1>
<h3>Deploying frontend and backend as a single Web Service</h3>
<h4>January 2025</h4>
</header>

<!-- Three Part Structure -->
<section id="three-part-structure" aria-labelledby="three-part-structure" data-item="Three Part Structure">
<h2>
<a href="#three-part-structure">Three Part Structure</a>
</h2>
<p>Part 1 explains how to can use the files in Project folder of this
repository as the foundation on which to start building your own
site.</p>
<p>Part 2 will show you how to build your own project, step by step,
from an empty folder. It will give you a full understanding of how the
files in the Project folder work</p>
<p>Part 3 explains how to deploy your Express-with-React backend to a
hosting service.</p>
<h2 id="just-need-a-project-template">Just need a project template?</h2>
<p>But perhaps all you want is a ready-made project template with a
workflow to make your life simpler. So perhaps Part 1 is the only part
you need.</p>
<details class="tip" open>
<summary>
Separate Git repositories
</summary>
<p>To make it easy for you to download this project, there is a hidden
<code>.git</code> file at the root of the
<code>Vite-React-Express</code> directory. If you want to use the files
in the Project directory as the foundation of your own project, you will
want to have a separate Git repository in both the <code>backend</code>
and the <code>frontend</code> directory. And you won’t want to have a
<code>.git</code> directory in their parent folder.</p>
<p>To make it easy to delete the existing <code>.git</code> directory
and create new ones in the <code>backend</code> and the
<code>frontend</code> directories, you can :</p>
<ol type="1">
<li>Open a Terminal window in the Project folder and run:</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">npm run split-git</code></pre>
<p>The custom <code>split-git</code> script will remove the Git
repository from the parent director and set up fresh new repositories in
both the <code>backend/</code> and <code>frontend/</code>
directories.</p>
<p>You want to have two separate Git repositories, because in the end,
you will be deploying only one (the backend) to an online hosting
site.</p>
<h2 id="create-matching-repositories-on-github">Create matching
repositories on GitHub</h2>
<p>Your new repositories will no longer be connected to GitHub, so you
should:</p>
<ol start="2" type="1">
<li><p>Create a separate GitHub repository for each of them</p></li>
<li><p>Use:</p>
<pre class="language-git wrap"><code class="language-git wrap">git remote add origin git@github.com:&lt;account&gt;/&lt;repo-name&gt;.git
git push -u origin main</code></pre>
<p>… (using your actual account and repository name) to push your new
local repositories to GitHub.</p></li>
</ol>
</details>
</section>
<!-- Starting the Backend -->
<section id="starting-the-backend" aria-labelledby="starting-the-backend" data-item="Starting The Backend">
<h1>
<a href="#starting-the-backend">Part 1: How the Workflow Works</a>
</h1>
<p>In this part, you will be seeing how to use the backend and frontend
that have already been built for you in the <code>Project</code>
folder.</p>
<h2 id="starting-the-backend">Starting the backend</h2>
<p>The frontend wants to connect to the backend, so you should start the
backend running first. And before you can start the backend, you will
need to install some Node modules. (This is treated in more depth in
section <a href="#nodejs-and-npm">9. NodeJS and NPM</a>)</p>
<ol type="1">
<li>Open a Terminal window on the <code>Project</code> directory</li>
<li>Run:</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">npm run setup</code></pre>
<p>(You can find this script in <code>Project/package.json</code>.) Your
Terminal will become busy displaying information and then it will stop.
When it finishes, look in the <code>backend</code> and
<code>frontend</code> directories. You’ll see that in each of them there
is a new <code>node_modules</code> directory, and a new file named
<code>package-lock.json</code>.</p>
<ol start="3" type="1">
<li>In the same Terminal window, run:</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">npm start</code></pre>
<p>You should see something like this.</p>
<pre class="language-bash wrap"><code class="language-bash wrap">james@M1 Project $ <b>npm start</b>

&gt; vite-react-express@1.0.0 start
&gt; npm run backend


&gt; vite-react-express@1.0.0 backend
&gt; npm --prefix ./backend start


&gt; start
&gt; nodemon server.js

[nodemon] 3.1.7
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,cjs,json
[nodemon] starting `node server.js`
🤚USING CORS FOR DEVELOPMENT
Server listening at http://localhost:3000</code></pre>
<p>The backend is already set up with some placeholder files in the
folder at <code>Vite-React-Express/Project/backend/public</code>. You
can:</p>
<ol type="1">
<li>Ctrl-Click on the link <a
href="http://localhost:3000">http://localhost:3000</a></li>
<li>Click on the green GET /ping button</li>
</ol>
<p>You should see a page like this:</p>
<figure>
<img src="images/dummyBackend.webp"
alt="The site served by the backend out of the box" />
<figcaption aria-hidden="true">The site served by the backend out of the
box</figcaption>
</figure>
Notice that the <code>referer</code> is
<code>http://localhost:3000/</code>, which is where your server is
running.
</section>
<!-- Starting the Frontend -->
<section id="starting-the-frontend" aria-labelledby="starting-the-frontend" data-item="Starting The Frontend">
<h2>
<a href="#starting-the-frontend">Starting The Frontend</a>
</h2>
<p>The Express backend serves up React static files that were built
using Vite. These files have been minified. You’ll find them in the
<code>backend/assets/</code> folder.</p>
<p>If you want to modify the frontend as you normally do:</p>
<ol type="1">
<li>Open a new Terminal in Project directory and run:</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">npm run dev</code></pre>
<p>You should see something like:</p>
<pre class="language-bash"><code class="language-bash">james@M1 Project $ <b>npm run dev</b>

&gt; vite-react-express@1.0.0 dev
&gt; npm --prefix ./frontend run dev


&gt; vite-react-frontend@0.0.0 dev
&gt; vite

VITE v6.0.1  ready in 98 ms

  ➜  Local:   http://localhost:5173/
  ➜  Network: use --host to expose
  ➜  press h + enter to show help</code></pre>
<ol start="2" type="1">
<li>Ctrl- (or Cmd-) Click on the URL to see it open in your
browser.</li>
<li>Click on the green GET /ping button</li>
</ol>
<figure>
<img src="images/dummyFrontend.webp"
alt="The current state of the React site in the front end" />
<figcaption aria-hidden="true">The current state of the React site in
the front end</figcaption>
</figure>
<p>The Vite development server launches its own frontend, using its own
localhost port. By default this will be <code>5173</code>.</p>
<p>The client page in your browser will connect to the Express backend
when it makes API requests. The Express backend allows CORS requests
from any source during development, and logs the CORS exceptions that it
makes for the frontend.</p>
<details class="note" open>
<summary>
CORS
</summary>
<p>If you look in the Terminal window where you launched the backend,
you will see that it has logged the fact that the frontend has been
given permission to connect:</p>
<pre class="language-bash wrap"><code class="language-bash wrap">
Server listening at http://localhost:3000
🤚DEV: PASS /ping REQUEST FOR http://localhost:5173/</code></pre>
At the moment, the frontend and the backend are serving different files
which happen to be identical, because of the workflow that you will be
learning to set up.
</details>
</section>
<!-- Publishing Changes -->
<section id="publishing-changes" aria-labelledby="publishing-changes" data-item="Publishing Changes">
<h2>
<a href="#publishing-changes">Publishing Changes</a>
</h2>
<p>Suppose you make a change to the frontend.</p>
<figure>
<img src="images/editFrontend.webp"
alt="A change in the frontend is updated live by Vite’s development server" />
<figcaption aria-hidden="true">A change in the frontend is updated live
by Vite’s development server</figcaption>
</figure>
<p>However, the site served by the backend doesn’t change. It takes only
one command to fix this.</p>
<ol type="1">
<li>Open a new Terminal in the Project directory</li>
<li>Run the following command</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">npm run publish</code></pre>
<p>You should see that this command tells Vite to <code>build</code> a
<code>dist</code> directory containing all the files needed to deploy
the React site. Then it copies the contents of the <code>dist</code>
directory to the <code>backend/public</code> folder.</p>
<pre class="language-bash wrap"><code class="language-bash wrap">james@M1 Project % <b>npm run publish</b>

&gt; vite-react-express@1.0.0 publish
&gt; npm run build && ./publish.sh


&gt; vite-react-express@1.0.0 build
&gt; npm --prefix ./frontend run build


&gt; vite-react-frontend@0.0.0 build
&gt; vite build

vite v6.0.1 building for production...
✓ 45 modules transformed.
dist/index.html                   0.50 kB │ gzip:  0.31 kB
dist/assets/index-DwHdCMGZ.css    1.05 kB │ gzip:  0.48 kB
dist/assets/index-D1TxUeB1.js   177.31 kB │ gzip: 58.55 kB
✓ built in 518ms
About to sync files from ./frontend/dist/ to ./backend/public/
building file list ... done
./
.DS_Store
index.html
nodoc.svg
vite.svg
assets/
assets/index-D1TxUeB1.js
assets/index-DwHdCMGZ.css

sent 188617 bytes  received 164 bytes  377562.00 bytes/sec
total size is 188089  speedup is 1.00
Files successfully synced.
james@M1 Project % </code></pre>
<details class="note" open>
<summary>
Refresh the Express page
</summary>
<p>You’ll notice that the browser page showing the site served by the
Express backend will not update immediately. Nodemon watches all the
files used by the Express server, and it restarts the server.</p>
<p>The Vite development server pushes changes to the browser live. This
is why you see your changes appear immediately. This is not Nodemon’s
job.</p>
<p>All you have to do is refresh the page showing the site served by
Express, and you will see that it matches the frontend.</p>
</details>
</section>
<!-- Part 2 Building the Workflow -->
<section id="building-the-workflow" aria-labelledby="building-the-workflow" data-item="Building The Workflow">
<h1>
<a href="#building-the-workflow">Part 2: Building The Workflow</a>
</h1>
<p>In this part, you will start with an empty directory, and bit-by-bit
build the workflow that you have just tested.</p>
<p>You will get practice in working in several different execution
environments:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>Environment</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>development</td>
<td>Your frontend will be served by Vite’s development server, your
backend by Express, both with the HTTP protocol. Vite’s Hot Module
Reload feature will allow you to see your frontend changes in real time
in the browser.</td>
</tr>
<tr>
<td>preview</td>
<td>At regular intervals, you will use a custom
<code>npm run publish</code> script. This creates a folder containing
static files for your frontend, and copies these automatically to the
<code>public/</code> folder in your backend. Both frontend and backend
will be served by your Express server over HTTP.<br>This will allow you
to preview the way your site will work in production, without the need
to deploy to a remote server.</td>
</tr>
<tr>
<td>production</td>
<td>You will create a GitHub repository for your backend (including the
<code>public</code> files created by your frontend) and deploy it to a
hosting service. The site will be delivered securely over HTTPS.</td>
</tr>
</tbody>
</table>
</section>
<!-- Organizing your files -->
<section id="organizing-your-files" aria-labelledby="organizing-your-files" data-item="Organizing Your Files">
<h2>
<a href="#organizing-your-files">Organizing Your Files</a>
</h2>
<p>While you are developing your site, it is good to use a separate
repository for the frontend and the backend. During development, your
Vite React frontend will be run by its own server on one port, and in
will connect to the backend running on another port. You can keep the
two repositories in separate folders inside a parent folder.</p>
<p>Your folder hierarchy will eventually look something like this:</p>
<pre class="language-bash"><code class="language-bash">MyProject
│
├── backend
│   ├── .env
│   ├── .git/
│   ├── .gitignore
│   ├── controllers/
│   ├── middleware/
│   ├── node_modules/
│   ├── package-lock.json
│   ├── package.json
│   ├── public/
│   ├── router.js
│   ├── server.js
│   └── public/
│
├── frontend
│   ├── .env
│   ├── .git/
│   ├── .gitignore
│   ├── dist/
│   ├── index.html
│   ├── node_modules/
│   ├── package-lock.json
│   ├── package.json
│   ├── public/
│   ├── src/
│   └── vite.config.js
│
├── publish.sh
└── package.json</code></pre>
<p>If you continue to Part 4 at the very end of the tutorial, where you
learn to set up an Nginx reverse proxy to run your site locally with the
HTTPS protocol, you will also have a folder named <code>nginx</code>.
But that will be the cherry on the cake.</p>
<p>To start with you can create the basic directory hierarchy. In a
Terminal, navigate to the directory where you want to create your
project and run the following command:</p>
<pre class="language-bash"><code class="language-bash">mkdir -p backend/public frontend/dist</code></pre>
<p>If your parent folder were called <code>MyProject</code>, you would
now have a directory structure like this:</p>
<pre class="line-numbers"><code class="line-numbers">MyProject
│ 
├── backend/
│   └── public/
│ 
└── frontend/
    └── dist/</code></pre>
<p>You are now ready to create a minimal server and a minimal frontend
for it to serve.</p>
</section>
<!-- A placeholder backend -->
<section id="placeholder-backend" aria-labelledby="placeholder-backend" data-item="Minimal Backend">
<h2>
<a href="#placeholder-backend">A Placeholder file in
<code>public/backend</code></a>
</h2>
<p>Your backend Express server is going to serve <em>static</em> files
from a directory called <code>public</code>. (You can call the directory
anything you want, but <code>public</code> is the name that is used
conventionally.) Later, you will create static React files using Vite,
but it’s best to start simply, with a proof-of-concept.</p>
<p>Inside <code>backend/public</code>, create a file called
<code>index.html</code> with the content shown below. This is just a
throwaway placeholder file, so you can just copy and paste it without
any further thought. You will be creating something much more meaningful
soon.</p>
<pre class="language-html line-numbers"><code class="language-html line-numbers">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta
    name="viewport"
    content="width=device-width, initial-scale=1.0"
  &gt;
  &lt;style&gt;
    body {
      margin: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #222;
      color: #ddd
    }

    h1 {
      font-size: 16vw;
    }
  &lt;/style&gt;
  &lt;title&gt;Placeholder&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Placeholder&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>You can Double-Click on this file to open it in your favourite
browser.</p>
<figure>
<img src="images/placeholder.webp"
alt="A placeholder file in backend/public" />
<figcaption aria-hidden="true">A placeholder file in
<code>backend/public</code></figcaption>
</figure>
<p>Now you can create the simplest Express server to serve up this
placeholder page.</p>
</section>
<!-- NodeJS and npm -->
<section id="nodejs-and-npm" aria-labelledby="nodejs-and-npm" data-item="NodeJS And Npm">
<h2>
<a href="#nodejs-and-npm">NodeJS And Npm</a>
</h2>
<p>You can skip this section if you already have a recent version of
<code>NodeJS</code> and <code>npm</code> installed. If not, read on.</p>
<h2 id="building-on-what-others-have-built">Building on what others have
built</h2>
<p>To go somewhere in your local city, you don’t need to build your own
car. Over the years, other people have built a public transport system,
and you can simply get on a bus and start heading in the right
direction. If the bus doesn’t go exactly where you want to go, you can
change buses, and walk the last few meters yourself. A bus ticket is
much cheaper than owning a car.</p>
<p>To create a web server, you don’t need to start from the very
beginning. Over the years, many open-source developers have worked
together and separately to build a modular set of tools. Like the buses
in a public transport system, these tools will do a great job of
connecting together to bring very close to where you want to go.</p>
<p>And what’s even better: the open-source ride is free.</p>
<p>Well… there is an understanding that if you benefit from the work of
others, you will pay it forward by making your own work open source, so
that others can benefit from it in turn. (This tutorial is written in
that spirit.)</p>
<p>As its <a href="https://nodejs.org/">home page</a> the NodeJS web
site says:</p>
<blockquote>
<p>Node.js® is a free, open-source, cross-platform JavaScript runtime
environment that lets developers create servers, web apps, command line
tools and scripts.</p>
</blockquote>
<p>You can read about its development <a
href="https://en.wikipedia.org/wiki/Node.js#History">here</a>.</p>
<p>Just like a bus is a self-contained unit of transport that works
together to build a cohesive transport system, Node Modules are
<em>packages</em> of code written for NodeJS, which work together to
take your end-user on the journey that you want to create.</p>
<p>For the server that you are about to create, you will be using four
Node Modules: Express, dotenv, CORS, jsonwebtoken and cookie-session.
(For the frontend, you will be using others.) The equivalent of a bus
station for NodeJS packages is <code>npm</code>, or Node Package
Manager, if you prefer to think of it that way (but <a
href="https://www.npmjs.com/package/npm#user-content-faq-on-branding">perhaps
you shouldn’t</a>).</p>
<p>I will use the words Node modules and Node packages as synonyms in
the text that follows.</p>
<p>You can use <code>NVM</code> or Node Version Manager to download and
install <code>NodeJS</code> and <code>npm</code>. You can find
instructions on how to do this for your operating system <a
href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm">here</a>.</p>
</section>
<!-- Installing Express -->
<section id="installing-express" aria-labelledby="installing-express" data-item="Installing Express">
<h2>
<a href="#installing-express">Installing Express</a>
</h2>
<p>Node packages can do most of your work for you. A bus will not
deliver you directly to your door. You will have to complete the last
part of your journey on foot.</p>
<p>All in all, you will be using five Node Modules to build your server:
<code>Express</code>, <code>dotenv</code>, <code>CORS</code>,
<code>jsonwebtoken</code> and <code>cookie-session</code>. For the
frontend, you will be using others. For now though, you can start with
just <a href="https://expressjs.com/">Express</a>.</p>
<p>To install Express for your project:</p>
<ol type="1">
<li>In a Terminal, navigate to the <code>backend/</code> directory in
your project</li>
<li>Make sure that you have an Internet connection</li>
<li>Run the command <code>npm i express</code></li>
</ol>
<p>The <code>i</code> here stands for <code>install</code>. You could
type <code>npm install express</code> if you want, but programmers like
to be lazy, and they make themselves shortcuts for everything that they
have to do often.</p>
<h2 id="what-the-npm-i-command-does">What the <code>npm i</code> command
does</h2>
<p>The <code>npm install</code> command connects to the <code>npm</code>
web site and downloads all the Node Modules that you’ll need to run an
Express server. You’ll see a lot of information appearing in your
Terminal window, ending up with something like this:</p>
<pre class="language-bash"><code class="language-bash">added 65 packages, and audited 66 packages in 2s

13 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities</code></pre>
<h2 id="node_modules"><code>node_modules/</code></h2>
<p>You’ll also see that a new directory called <code>node_modules</code>
has appeared in your <code>backend/</code> directory, along with two
files called <code>package.json</code> and
<code>package-lock.json</code>. If you open the
<code>node_modules/</code> directory, you will find it full of folders.
There will be one called <code>express</code>, and all the others will
be the <em>dependencies</em> that Express requires in order to run. You
have basically downloaded an entire transport network that ensures that
the data your project needs gets shipped to the right places in good
time.</p>
<h2 id="package.json"><code>package.json</code></h2>
<p>Open the <code>package.json</code> file. It should look something
like this:</p>
<pre class="language-json line-numbers"><code class="language-json line-numbers">{
  "dependencies": {
    "express": "^4.21.1"
  }
}</code></pre>
<p>The version number that you see might be different. That’s OK.</p>
<p>This <code>dependencies</code> block describes all the Node Modules
that your project needs to work with. This is what tells the Node
Package Manager what packages to download.</p>
<p>The <code>package-lock.json</code> file gives even finer detail. It
lists all the dependencies, with their actual version numbers, that have
been installed for you in the <code>node_modules/</code> directory. If
you give these two files to a co-worker, and they put them in a
directory and run <code>npm i</code> in the Terminal, <code>npm</code>
will download <em>exactly the same files</em> for your co-worker. This
ensures that you can work together with exactly the same tools.</p>
</section>
<!-- Simple Express Server -->
<section id="simple-express-server" aria-labelledby="simple-express-server" data-item="Basic Express Server">
<h2>
<a href="#simple-express-server">A Minimal Express Server</a>
</h2>
<p>The Express package and the built-in NodeJS modules can do almost all
your work for you, but you still need to write a few lines of code.</p>
<ol type="1">
<li>Create a file in the <code>backend/</code> directory called
<code>server.js</code></li>
<li>Give it the content that you see below.</li>
</ol>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">/**
 * server.js
 */

const express = require('express')
const PORT = 3000

const server = express()
server.use(express.static('public'));

server.listen(PORT, () =&gt; {
  console.log(`Server listening at http://localhost:${PORT}`)
})</code></pre>
<p>That’s enough to get started with.</p>
<p>Line 5 tells NodeJS to load all the files from the
<code>node_modules/express/</code> directory (and all the dependencies
that <em>they</em> need, which are found in the other directories inside
<code>node_modules/</code>).</p>
<p>Line 6 defines which <a
href="https://en.wikipedia.org/wiki/Port_(computer_networking)">port</a>
your browser can connect to, in order to access your server. You can
think of a <em>port</em> as being the computer equivalent of a bus stop.
If your browser goes to that point, it will find the service it
needs.</p>
<p>Line 8 tells NodeJS to create a <code>server</code> object, using all
the magic that <code>express</code> gives you.</p>
<p>The line …</p>
<pre class="language-javascript line-numbers" data-start="9"><code class="language-javascript line-numbers">server.use(express.static('public'));</code></pre>
<p>… tells your <code>server</code> that, if the server receives a
request from your browser for a file that can be found in the folder
<code>backend/public/</code>, then that’s the file that the
<code>server</code> should send that file back to the browser.</p>
<p>It takes the Express module many many lines of code to convert the
browser’s request into a file that is sent back to the browser, but all
you need is this one line of code as your ticket for this journey.</p>
<p>Finally, the section…</p>
<pre class="language-javascript line-numbers" data-start="11"><code class="language-javascript line-numbers">server.listen(PORT, () =&gt; {
  console.log(`Server listening at http://localhost:${PORT}`)
})</code></pre>
<p>… tells the <code>server</code> to do all the work that is needed to
open port 3000 on your local network and to listen on that port for
requests from your browser. As soon as the <code>listen</code> command
is complete, the <em>callback</em> function will log a message in the
Terminal window.</p>
<p>All that you need to do now is to start your server.</p>
</section>
<!-- Starting the server -->
<section id="starting-the-server" aria-labelledby="starting-the-server" data-item="Starting The Server">
<h2>
<a href="#starting-the-server">Starting The Server</a>
</h2>
<p>In your Terminal open in the <code>backend/</code> directory, run the
command:</p>
<pre class="language-bash line-numbers"><code class="language-bash line-numbers">node server.js</code></pre>
<p>This tells the NodeJS application to read the <code>server.js</code>
file, and to follow the instructions. You should see something like the
following in the Terminal window:</p>
<pre class="language-bash"><code class="language-bash">$ <b>node server.js</b>
Server listening at http://localhost:3000</code></pre>
<p>You can press the <code>Ctrl</code> key (or <code>Cmd</code> if your
are working on a Mac) and at the same time click on the link
<code>http://localhost:3000</code>. Your favourite browser should open
and show the “Placeholder” site that you created in <a
href="#placeholder-backend">8. Minimal Backend</a>. This time, the URL
in the address bar is different.</p>
<figure>
<img src="images/localholder.webp"
alt="The file at backend/public/index.html served by your Express server" />
<figcaption aria-hidden="true">The file at
<code>backend/public/index.html</code> served by your Express
server</figcaption>
</figure>
<p>You’ve done quite a lot of work, just to get back to almost the same
place where you started. But now, you are not just a passenger; you are
in control of where things are going to go. So now, you can start
delegating some of your work.</p>
</section>
<!-- npm scripts -->
<section id="npm-scripts" aria-labelledby="npm-scripts" data-item="npm Scripts">
<h2>
<a href="#npm-scripts">Making<code>npm</code> work for you</a>
</h2>
<p>The <code>npm</code> program can do much more than just installing
Node packages for you. It can also run scripts. Remember the
<code>package.json</code> file that was created in section <a
href="#installing-express">10. Installing Express</a>?</p>
<p>Add a new <code>"scripts"</code> block to the file, as shown
below:</p>
<pre class="language-json line-numbers"><code class="language-json line-numbers">{
  "dependencies": {
    "express": "^4.21.1"
  },
  "scripts": {
    "start": "node server.js"
  }
}</code></pre>
<p>What do you think will happen if you do the following?</p>
<ol type="1">
<li>Open a new Terminal window in the <code>backend/</code>
directory</li>
<li>Run the command <code>npm start</code></li>
</ol>
<p>Actually, you’ll probably see your new Terminal fill up with a long
error message, starting like this:</p>
<pre class="language-bash"><code class="language-bash">$ <b>npm start</b>

&gt; start
&gt; node server.js

node:events:485
      throw er; // Unhandled 'error' event
      ^

Error: listen EADDRINUSE: address already in use :::3000</code></pre>
<p>Don’t worry. Error messages are your friends. They explain, often
with too much information, what went wrong.</p>
<p>This one reminds you that you just started your server running on
port 3000, with the command <code>node server.js</code>, and you can’t
have two servers listening on the same port.</p>
<details class="warn" open>
<summary>
A different error?
</summary>
<p>Perhaps you see a different error. Perhaps, hidden in the error that
you see is the line <code>Could not read package.json</code>. That would
suggest that you <strong>did not
<code>Open a new Terminal window in the</code>backend/<code>directory</code></strong>,
like I suggested, or that there is an error in the
<code>package.json</code> file. Try running <code>cd backend</code> and
<em>then</em> <code>npm start</code>.</p>
</details>
<p>To fix the problem with <code>EADDRINUSE</code>:</p>
<ol type="1">
<li>Return to the Terminal where you initially ran
<code>node server.js</code></li>
<li>Press <code>Ctl-C</code> (even on a Mac)</li>
</ol>
<p>This should stop your server.</p>
<details class="note" open>
<summary>
Ctl-C is older than Windows
</summary>
<p>In the Terminal, <code>Ctl-C</code> means <em>Cancel</em>. It does
<em>not</em> mean <em>Copy</em>. This is because the Terminal shortcut
was established long before <code>Ctrl-C</code> was given a different
meaning by Microsoft Windows at the end of the last century. If you want
to <em>copy</em> something from the Terminal, you must use
<code>Shift-Ctl-C</code>.</p>
</details>
<p>Now that your server has stopped, port 3000 is free again, and you
can run <code>npm start</code>. And your server starts up again, and
tells you:</p>
<pre class="language-bash"><code class="language-bash">$ npm start

&gt; start
&gt; node server.js

Server listening at http://localhost:3000</code></pre>
<p>More work, just to arrive at the same place : )</p>
</section>
<!-- making npm make npm work -->
<section id="making-npm-make-npm-work" aria-labelledby="making-npm-make-npm-work" data-item="npm Can Control npm">
<h2>
<a href="#making-npm-make-npm-work">Making <code>npm</code> make
<code>npm</code> work</a>
</h2>
<p>For now, only the <code>backend/</code> directory contains any useful
code, but later the <code>frontend/</code> directory will also contain
code. You can take a step back, and direct both parts of your project
from the parent folder. I’m going to show you how.</p>
<ol type="1">
<li><p><strong>Press <code>Ctl-C</code> to stop the server
again</strong>, and used</p></li>
<li><p>Use <code>cd ..</code> to navigate into the parent folder
(<code>MyProject</code> or whatever folder contains both your
<code>backend/</code> and your <code>frontend/</code> folders).</p></li>
<li><p>Run <code>ls -1F</code>.</p></li>
</ol>
<p>(That’s the digit “one” between <code>-</code> and <code>F</code>).
This should show the contents of the parent folder:</p>
<pre class="language-bash"><code class="language-bash">$ ls -1F
backend/
frontend/</code></pre>
<details class="note" open>
<summary>
ls
</summary>
<p><code>ls</code> means <code>list</code> (because programmers don’t
like typing). The <code>-1</code> flag means “show one item on each
line”, and the <code>-F</code> flag (which stands for
<i>classi<b>f</b>y</i>) means “show the<code>/</code> character if an
item is a directory”. You can run all the flags together, following the
initial <code>-</code> flag indicator character, which gives you
<code>-1F</code>. You can find the complete manual for the
<code>ls</code> program <a
href="https://man7.org/linux/man-pages/man1/ls.1.html">here</a>.</p>
</details>
<ol start="2" type="1">
<li>Run <code>npm init -y</code></li>
</ol>
<p>This will create a <code>package.json</code> file in the parent
folder.</p>
<p>If you run <code>ls -1F</code> again, you should now see:</p>
<pre class="language-bash"><code class="language-bash">ls -1F     
backend/
frontend/
package.json</code></pre>
<ol start="3" type="1">
<li>Take a look at what this new <code>package.json</code> file
contains. Your entry for <code>"name"</code> will depend on the name of
the parent folder you are working in.</li>
</ol>
<pre class="language-json line-numbers"><code class="language-json line-numbers">{
  "name": "myproject",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": ""
}</code></pre>
<details class="note" open>
<summary>
The secrets of <code>package.json</code>
</summary>
<p>I’ve got you to create this file so that you can edit the
<code>"scripts"</code> block, but you might like to review what the
other sections are for. In short, they make it easy for other
open-source developers to find your project, when you make it public.
They might want to collaborate with you, or fork your project and take
it a different direction.</p>
<ul>
<li>The value of the<code>"name"</code> property will be the name of the
parent folder in lower case.</li>
<li>You can leave <code>"version"</code> as it is.</li>
<li>You can change the value for <code>"main"</code> to
<code>"backend/server.js"</code>, to tell other developers which file to
execute to start your app.</li>
<li>I’ll deal with the <code>"scripts"</code> field in detail in a
moment</li>
<li>You can add words in double-quotes to the array for
<code>"keywords"</code> to help others to find your open-source project.
You know best what you want your project to become, so it’s your choice.
I am creating my project to help people like you work efficiently with
Express and React, so I might use
<code>["express", "react", "backend", "server", "vite"]</code> for my
keywords.</li>
<li>The value you set for <code>"author"</code> will help people to find
all the projects that you have worked on.</li>
<li>By default, <code>npm</code> assumes that you will want to allow
other developers to copy and remix your work. The <a
href="https://en.wikipedia.org/wiki/ISC_license">ISC licerse</a> makes
this explicit. You can choose a different license if you want, or you
can choose not to let other people benefit from your goodwill. It’s up
to you.</li>
<li>The <code>"description"</code> can be a sentence to attract
attention you your project. In my case, it could be <em>“Using Express
to deliver a React frontend created with Vite”</em> or <em>“Serve the
build of a React app with Express”</em>.</li>
</ul>
</details>
<h2 id="a-new-start-script">A new <code>"start"</code> script</h2>
<p>I won’t be getting you to write any tests for this project, so you
can replace the current <code>"scripts"</code> block with this:</p>
<pre class="language-json line-numbers" data-start="5"><code class="language-json line-numbers">  "scripts": {
    "backend": "npm --prefix ./backend start",
    "start": "npm run backend"
  },</code></pre>
<p>I could have made this simpler, but this <code>"scripts"</code> block
illustrates a useful technique. You can get one entry in the block to
<code>run</code> another entry.</p>
<ol type="1">
<li>Run this command in the Terminal from the parent folder:
<code>npm start</code></li>
</ol>
<pre class="language-bash"><code class="language-bash">$ <b>npm start</b>

&gt; myproject@1.0.0 start
&gt; npm run backend

&gt; myproject@1.0.0 backend
&gt; npm --prefix ./backend start

&gt; start
&gt; node server.js

Server listening at http://localhost:3000</code></pre>
<p>Once again your server has started (assuming that you pressed
<code>Ctl-C</code>, to stop the server, like I asked you to do at the
beginning of this section).</p>
<p>The instruction <code>--prefix ./backend</code> tells
<code>npm</code> to navigate into the <code>backend/</code> directory
before running the <code>"start"</code> script that is defined in
<code>backend/package.json</code>.</p>
<p><code>npm</code> allows you to use two commands directly:
<code>test</code> and <code>start</code>. For any other script names
that you might want to use, you have to explicitly use the
<code>run</code> command. <code>npm run start</code> will work fine, but
<code>npm backend</code> (without the <code>run</code> command) will
fail.</p>
<p>So now, you can execute a command from the parent folder, and have it
act on files in the sub-folders. In the next section, you’ll see how to
use this to move files from the <code>frontend/</code> folder to the
<code>backend/</code>.</p>
</section>
<!-- Using frontend files -->
<section id="using-frontend-files" aria-labelledby="using-frontend-files" data-item="Using Frontend Files">
<h2>
<a href="#using-frontend-files">Using Files from the Frontend</a>
</h2>
<p>Soon, you’ll be using Vite to create a React frontend, but for now,
you can do a simple simulation of what needs to happen when you develop
the frontend in its own directory.</p>
<p>Here’s how you can copy the <code>index.html</code> file from the
<code>backend/public/</code> directory into the
<code>frontend/dist/</code> directory. You can do this by:</p>
<ol type="1">
<li>Open a new Terminal window in the parent directory for your
project</li>
<li>Run:</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">cp backend/public/index.html frontend/dist/</code></pre>
<p>This means: <b>c</b>o<b>p</b>y the <code>index.html</code> file that
is inside the <code>backend/public/</code> folder (relative to this
parent folder), into the <code>frontend/dist/</code> older.</p>
<p>The <code>dist/</code> directory is the folder that Vite will use
when it <code>build</code>s the deployment version of your React
frontend.</p>
<ol start="3" type="1">
<li>Open the file that has been created at
<code>frontend/dist/index.html</code></li>
<li>Make some changes in this copy of the file. For instance:
<ul>
<li>Change the color of the <code>&lt;h1&gt;</code> text to a deep
red</li>
<li>Use <code>Frontend</code> instead of <code>Placeholder</code> for
the <code>&lt;title&gt;</code> an the <code>&lt;h1&gt;</code> text
itself</li>
</ul></li>
</ol>
<pre class="language-html line-numbers"><code class="language-html line-numbers"><i>&lt;!DOCTYPE html&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta
    name="viewport"
    content="width=device-width, initial-scale=1.0"
  &gt;
  &lt;style&gt;
    body {
      margin: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #222;
      color: #ddd
    }

    h1 {
      font-size: 16vw;</i>
      <b>color: #900;</b>

    }
  &lt;/style&gt;
  &lt;title&gt;</i><b>Placeholder</b><i>&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;</i><b>Placeholder</b></i>&lt;/h1&gt;
&lt;/body&gt;</i></code></pre>
<p>You can open this new <code>index.html</code> file direcly in your
browser, to be sure that it looks different from the previous
Placeholder page.</p>
<figure>
<img src="images/frontholder.webp"
alt="The frontend is different from the backend" />
<figcaption aria-hidden="true">The frontend is different from the
backend</figcaption>
</figure>
Now you can write a couple of scripts to make the Express server deliver
this page instead of the Placeholder page it served up before.
</section>
<!-- Using rsync -->
<section id="using-rsync" aria-labelledby="using-rsync" data-item="Using `rsync`">
<h2>
<a href="#using-rsync">Using the <code>rsync</code> command</a>
</h2>
<p>The site served by your Express server has not changed. To get it to
display the <code>index.html</code> file that you created in
<code>frontend/dist/</code>, you will need to copy it from
<code>frontend/dist/</code> to <code>backend/public</code>. You can do
this in little steps.</p>
<p>You can start with a command that will copy your newest version of
<code>index.html</code> into the <code>backend/public</code> folder,
replacing the version that is currently there.</p>
<pre class="language-bash"><code class="language-bash">rsync -a ./frontend/dist/ ./backend/public/</code></pre>
<details class="env" open>
<summary>
<code>rsync</code> on Windows
</summary>
<p>If you are developing on Windows, using Git bash, you may need to <a
href="https://gist.github.com/radleta/0b337a2b14f761951cf2aab0578512b9">install
<code>rsync</code></a> manually before you can use it.</p>
</details>
<p>This command tells the <code>rsync</code> program to compare the
items inside <code>frontend/dist/</code> with the files in
<code>backend/public/</code>. If it finds any files or folders with the
same names, it should copy <em>just the differences</em> between these
files and folders to <code>backend/public/</code>. The <code>-a</code>
flag ensures that this behaves like an <em>archiving</em> process: all
modification dates, permissions and owner data will be preserved.</p>
<p>In a Terminal window:</p>
<ol type="1">
<li>Ensure that the Terminal is active the parent directory of your
project and run the <code>rsync</code> command shown above.</li>
<li>Ensure that your server is running at port 3000</li>
<li>Open (or refresh) your browser at the address <a
href="http://localhost:3000/">http://localhost:3000/</a></li>
</ol>
<p>Your server is still serving up the <code>index.html</code> file that
it finds in its <code>public/</code> folder, but this
<code>index.html</code> file is now an exact copy of the
<code>index.html</code> file in the <code>frontend/dist/</code>
folder.</p>
<figure>
<img src="images/localfront.webp"
alt="The new frontend is now served by the Express server" />
<figcaption aria-hidden="true">The new frontend is now served by the
Express server</figcaption>
</figure>
</section>
<!-- Writing a shell Script -->
<section id="writing-a-shell-script" aria-labelledby="writing-a-shell-script" data-item="Writing a shell Script">
<h2>
<a href="#writing-a-shell-script">Writing a <code>shell</code>
script</a>
</h2>
<p>You might be just about to enter new territory.</p>
<p>In order to automate the process so that you can run it with a single
<code>npm</code> command, it would be good to write a <code>shell</code>
script, complete with sanity checks, that you can customize for your
future needs.</p>
<p>You have experience with running simple <code>bash</code> commands in
the Terminal, like <code>ls</code> or <code>cd</code> or
<code>npm</code>, or, just now <code>rsync</code>. You have experience
in writing JavaScript scripts (like <code>server.js</code>) and running
them with a <code>bash</code> command (like <code>node server.js</code>)
in the Terminal. For the next part of your journey, you will be seeing
how to write a <em>shell script</em>: a script that runs a series of
<code>bash</code> commands.</p>
<p>The reason for writing a <code>shell</code> script is that <a
href="https://linux.die.net/man/1/rsync"><code>rsync</code></a>, is a
“fast and extraordinarily versatile file copying tool” which is already
installed on your computer. NodeJS does not provide this kind of power,
and there’s no need to reinvent the wheel. It would be possible to use a
NodeJS wrapper script that calls <code>rsync</code> for you, but it’s
much simpler to use <code>rsync</code> in its native environment.</p>
<ol type="1">
<li>In the parent folder of your project (MyProject), create a file
called <code>publish.sh</code>. (The <code>.sh</code> extension stands
for <b>sh</b>ell script.)</li>
<li>Paste the contents the code listing below into your new file.</li>
</ol>
<pre class="language-shell line-numbers"><code class="language-shell line-numbers">#!/bin/bash

# Define the paths for dist and the target directory
DIST_DIR="./frontend/dist/"
PUBLIC_DIR="./backend/public/"
ASSETS="$PUBLIC_DIR"assets/

# Ensure the script is run from the correct location
if [ ! -d "$DIST_DIR" ]; then
  echo "Error: $DIST_DIR does not exist. Please make sure 'vite build' has been run."
  exit 1
fi

if [ ! -d "$PUBLIC_DIR" ]; then
  echo "Error: $PUBLIC_DIR does not exist. Please make sure the backend directory is set up correctly."
  exit 1
fi

# Copy everything from dist/ to ../backend/public using rsync
echo "About to sync files from $DIST_DIR to $PUBLIC_DIR"

echo "These files in the $ASSETS folder may be out of date:"
ls "$ASSETS"
read -p "Do you want to delete them ([y]es or [N]o): " -n 1 -r
echo # (optional) move to a new line
if [[ $REPLY =~ ^[Yy]$ ]]
then
    # do dangerous stuff
    echo "Deleting the files..."
    rm -rf "$ASSETS"
else
    echo "No files were deleted."
fi

rsync -a --verbose "$DIST_DIR/" "$PUBLIC_DIR/"
echo "Files successfully synced."</code></pre>
<details class="tldr">
<summary>
All about <code>publish.sh</code>
</summary>
<p>This script is well commented, so that it doesn’t matter if you don’t
understand the intricacies of all the <code>bash</code> syntax; you can
still understand what it does.</p>
<p>Just note, though, that lines 22 to 33 are likely to annoy you. Line
30 does something destructive. The command
<code>rm -rf &lt;some folder&gt;</code> can be devasting, with no hope
of recovery.</p>
<p>The first line contains what is known as the <a
href="https://en.wikipedia.org/wiki/Shebang_(Unix)"><em>shebang
interpreter directive</em></a>:</p>
<pre class="language-shell line-numbers"><code class="language-shell line-numbers">#!/bin/bash</code></pre>
<p>When you run <code>publish.sh</code> as an executable program, this
line tells your Terminal what program (<code>bash</code>) to use to run
it.</p>
<p>Lines 4-6 create variables that you can set to indicate where to find
the source and target folders for the <code>rsync</code> operation:</p>
<pre class="language-shell line-numbers" data-start="4"><code class="language-shell line-numbers">DIST_DIR="./frontend/dist/"
PUBLIC_DIR="./backend/public/"
ASSETS="$PUBLIC_DIR"assets/</code></pre>
<p>In <code>bash</code>, when a variable is created, the variable name
must be followed immediately by <code>=</code> and then by the value,
with no spaces. When the variable is used, it must be given the
<code>$</code> character as a prefix. It is safest to wrap the variable
name in <code>"</code> double quotes.</p>
<p>Lines 9 to 17 simply check that the source and target folders exist,
and prevent the script from going any further if they don’t.</p>
<p>The <code>vite build</code> process will generate a <code>.js</code>
and a <code>.css</code> file with arbitrary names. Each time your
JavaScript or CSS is changed, a new file, with a new arbitrary name will
be created inside the <code>frontend/dist/assets/</code> directory. You
don’t want your <code>backend/public/assets/</code> directory to fill up
with out of date files, so lines 22 to 33 list the files that will be
deleted, and ask you if you really want to delete them.</p>
<p>In fact, only line 30 is essential. If you are confident that the
script is correctly targeting the correct
<code>backend/public/assets/</code> directory, you can comment out lines
22 - 29 and lines 31-33, by placing a <code>#</code> at the beginning of
each of these lines.</p>
<pre class="language-shell line-numbers" data-start="22"><code class="language-shell line-numbers"># echo "These files in the $ASSETS folder may be out of date:"
# ls "$ASSETS"
# read -p "Do you want to delete them ([y]es or [N]o): " -n 1 -r
# echo # (optional) move to a new line
# if [[ $REPLY =~ ^[Yy]$ ]]
# then
#     # do dangerous stuff
#     echo "Deleting the files..."
    rm -rf "$ASSETS"
# else
#     echo "No files were deleted."
# fi</code></pre>
<p>Unless you comment out these lines, you’ll have to press ‘Y’ on your
keyboard each time you run the <code>npm run publish</code> script.</p>
<p>Line 35 is where the <code>rsync</code> command that you saw earlier
is run. I’ve added the <code>--verbose</code> flag so that a summary of
all the files that were updated is shown in the Terminal.</p>
</details>
</section>
<!-- Using the shell Script -->
<section id="using-the-shell-script" aria-labelledby="using-the-shell-script" data-item="Using the Shell Script">
<h2>
<a href="#using-the-shell-script">Using the Shell Script</a>
</h2>
<p>Your project folder should now have a structure like this:</p>
<pre class="language-bash"><code class="language-bash">MyProject
│
├── backend
│   ├── node_modules/
│   ├── package-lock.json
│   ├── package.json
│   ├── public
│   │   └── index.html
│   └── server.js
│   
├── frontend
│   └── dist
│       └── index.html
│   
├── package.json
└── publish.sh  &lt;&lt;&lt; New file</code></pre>
<ol type="1">
<li>Delete the <code>index.html</code> file from
<code>backend/public</code></li>
<li>Refresh your browser. Because <code>index.html</code> is missing,
you should see <code>Cannot GET /</code></li>
<li>In a Terminal window at the parent folder, run</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">bash ./publish.sh</code></pre>
<ol type="1">
<li>Refresh your browser window. You should see the
<strong>Frontend</strong> page again.</li>
</ol>
<p>In your Terminal window, you should see something like this:</p>
<pre class="language-bash"><code class="language-bash">$ npm run publish

&gt; myproject3@1.0.0 publish
&gt; npm run build && ./publish.sh


&gt; myproject@1.0.0 build
&gt; npm --prefix ./frontend run build


&gt; frontend@0.0.0 build
&gt; vite build

vite v6.0.1 building for production...
✓ 44 modules transformed.
dist/index.html                   0.45 kB │ gzip:  0.30 kB
dist/assets/index-DJaG3xuZ.css    1.23 kB │ gzip:  0.62 kB
dist/assets/index-BZVNIzQ0.js   177.36 kB │ gzip: 58.54 kB
✓ built in 484ms
About to sync files from ./frontend/dist/ to ./backend/public/
These files in the ./backend/public/assets/ folder may be out of date:
index-BZVNIzQ0.js       index-DJaG3xuZ.css
Do you want to delete them ([y]es or [N]o): y
Deleting the files...
building file list ... done
./
index.html
vite.svg
assets/
assets/index-BZVNIzQ0.js
assets/index-DJaG3xuZ.css

sent 180923 bytes  received 120 bytes  362086.00 bytes/sec
total size is 180537  speedup is 1.00
Files successfully synced.</code></pre>
</section>
<!-- An executable script -->
<section id="an-executable-script" aria-labelledby="an-executable-script" data-item="An Executable Script">
<h2>
<a href="#an-executable-script">Making your <code>publish.sh</code>
script executable</a>
</h2>
<p>I got you to cheat a little. I got you to use the <code>bash</code>
command:</p>
<pre class="language-bash line-numbers"><code class="language-bash line-numbers">bash ./publish.sh</code></pre>
<p>You could make the <code>publish.sh</code> file executable, so that
you can run it as a program in its own write. Remember that the shebang
interpreter directive tells your Terminal to use <code>bash</code> to
execute this file.</p>
<ol type="1">
<li>In the Terminal, run the command <code>ls -1lF</code></li>
</ol>
<p>You should see something like this:</p>
<pre class="language-bash"><code class="language-bash"><i>ls -1lF          
total 16
drwxr-xr-x  7 james  staff  224 Nov 25 20:07 backend/
drwxr-xr-x  3 james  staff   96 Nov 25 20:26 frontend/
-rw-r--r--  1 james  staff  367 Nov 25 20:11 package.json</i>
</i><b>-rw-r--r--</b><i>  1 james  staff  656 Nov 25 20:20 publish.sh</i></code></pre>
<p>The <code>-l</code> flag (that’s a lower-case “L”), tells the
<code>ls</code> listing command to show information about file
permissions, ownership and the last modification date. You can see that
the permissons for <code>publish.sh</code> are
<code>-rw-r--r--</code>.</p>
<p>This permissions string can be divided into four blocks:</p>
<pre class="language-bash"><code class="language-bash">-
rw-
r--
r--</code></pre>
<p>The first character is <strong>not</strong> a <code>d</code>, so the
file is not a <b>d</b>irectory (but <code>backend/</code> and
<code>frontend/</code> are directories, so they have a <code>d</code>
for the first character).</p>
<p>The second block gives the premissions of the owner (the user
<code>james</code> in my case). The permissions <code>rw-</code> mean
that I can <b>r</b>ead from and <b>w</b>rite to the file, but I cannot
e<b>x</b>ecute the file.</p>
<p>The third block says that other members of the group
(<code>staff</code>) have <code>r--</code> read-only permissions. The
fourth block says that any one else, who is not a member of the group
<code>staff</code> also has <code>r--</code> read-only permissions.</p>
<p>To make the <code>publish</code> script executable by you (the
owner), and you only, you need to modify the permissions so that they
become <code>-rwxr--r--</code>. You can do this with the <a
href="https://linux.die.net/man/1/chmod"><code>chmod</code></a>command:</p>
<pre class="language-bash wrap"><code class="language-bash wrap">chmod u+x publish.sh</code></pre>
<p>This means:</p>
<ul>
<li><b>ch</b>ange the</li>
<li><b>mod</b>e for the</li>
<li><b>u</b>ser (owner) by</li>
<li><strong>+</strong> adding an</li>
<li><strong>x</strong> to the permissions for the file</li>
<li><strong>publish.sh</strong></li>
</ul>
<ol start="2" type="1">
<li>Run the command <code>chmod u+x publish.sh</code></li>
<li>Run the command <code>ls -1lF</code> again. (Hint: you can press the
Up arrow on your keyboard to move back up through the history of your
commands. If you press it once, the command
<code>chmod u+x publish.sh</code> should appear again. If you press it
twice the command <code>ls -1lF</code> will reappear, and you can simply
press the Enter key.)</li>
</ol>
<p>You should see that the line for <code>publish.sh</code> has
changed.</p>
<pre class="language-bash"><code class="language-bash"><i>$ chmod u+x publish.sh
$ ls -lF              
total 16
drwxr-xr-x  8 james  staff  256 Nov 16 23:49 backend/
drwxr-xr-x  3 james  staff   96 Nov 16 21:11 frontend/
-rw-r--r--  1 james  staff  243 Nov 17 00:23 package.json</i>
</i><b>-rwxr--r--</b><i>  1 james  staff  656 Nov 17 13:14 publish.sh</i><b>*</b></code></pre>
<p>There is now an <code>x</code> in the fourth place, and an
<code>*</code> asterisk at the end to say: “this file is executable”</p>
<ol start="4" type="1">
<li>In the Terminal type just <code>./publish.sh</code> and press the
Enter key</li>
</ol>
<pre class="language-bash"><code class="language-bash">$ ./publish.sh 
About to sync files from ./frontend/dist/ to ./backend/public/
building file list ... done

sent 96 bytes  received 20 bytes  232.00 bytes/sec
total size is 490  speedup is 4.22
Files successfully synced.</code></pre>
<p>The <code>publish.sh</code> script will run again, but this time the
<code>index.html</code> files are the same in both folders, so there is
no need to actually copy anything.</p>
</section>
<!-- Run with npm -->
<section id="run-with-npm" aria-labelledby="run-with-npm" data-item="Run with npm">
<h2>
<a href="#run-with-npm">Calling your <code>shell</code> Script with
<code>npm</code></a>
</h2>
<p>In the last section, you added two script definitions to the
<code>package.json</code> file at the root of your parent folder. Now
you are ready to add a third script.</p>
<ol type="1">
<li>Edit the <code>package.json</code> file so that the
<code>"scripts"</code> looks the same as in the code listing below:</li>
<li></li>
</ol>
<pre class="language-json line-numbers"><code class="language-json line-numbers"><i>{
  "name": "myproject",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "backend": "npm --prefix ./backend start",
    "start": "npm run backend"</i><b>,
    "publish": "./publish.sh"</b><i>
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": ""
}</i></code></pre>
<ol start="2" type="1">
<li>Now run <code>npm run publish</code> in your Terminal.</li>
</ol>
<p>The <code>index.html</code> files are still identical, so the output
should be similar to what is shown in the output in the last
section.</p>
<details class="pivot" open>
<summary>
Time for the frontend
</summary>
<p>Now it’s time to start using Vite to build your frontend, and to use
all the tricks that you have just learnt to get your Express backend
server to serve up your React frontend.</p>
</details>
</section>
<!-- barebones frontend -->
<section id="barebones-frontend" aria-labelledby="barebones-frontend" data-item="A Basic Frontend">
<h2>
<a href="#barebones-frontend">A Barebones React Frontend</a>
</h2>
<p>With only a little input in the Terminal, you can create a
proof-of-concept React app using Vite.</p>
<ol type="1">
<li>In your Terminal window, run <code>cd frontend</code></li>
<li>Run <code>npm create vite@latest .</code></li>
</ol>
<p>The <code>.</code> dot at the end says “in the current directory”, so
the whole command says: “<code>npm</code>, tell Vite to use its latest
version to create a new project in this <code>frontend/</code>
directory, so there’s no need to ask for a directory name.”</p>
<p>Vite will discover that there is already a <code>dist/</code>
directory in the current directory, so it will ask you what to do about
this:</p>
<pre class="language-bash wrap"><code class="language-bash wrap">? Current directory is not empty. Please choose how to proceed: › - Use arrow-keys. Return to submit.
❯   Cancel operation
    Remove existing files and continue
    Ignore files and continue</code></pre>
<details class="warn" open>
<summary>
No warning?
</summary>
<p>If you don’t see this warning, it probably means that you did not use
a <code>.</code> dot in the correct place at the end of the command.</p>
<p>If you see a request for a <code>Project name</code>, press
<code>^C</code> (Ctl-C), and try again with a space and a <code>.</code>
dot at the end this time.</p>
</details>
<p>You know that the <code>index.html</code> file that you created in
<code>dist/</code> was designed to be thrown away, so you can choose the
first option: <code>❯   Remove existing files and continue</code>.</p>
<ol start="3" type="1">
<li>Use the arrow keys to move the selection to the line that says
“Remove files”</li>
</ol>
<pre class="language-bash line-numbers"><code class="language-bash line-numbers">❯   Remove existing files and continue</code></pre>
<ol start="4" type="1">
<li>Press the Enter key to tell Vite to delete the <code>dist/</code>
directory and all its contents, forever</li>
</ol>
<p>Now you will be asked to select a framework. and some other
details.</p>
<ol start="5" type="1">
<li>Press the down arrow on your keyboard twice, to select
<code>React</code> and then press the Enter key.</li>
</ol>
<pre class="language-bash"><code class="language-bash">? Select a framework: › - Use arrow-keys. Return to submit.
    Vanilla
    Vue
<b>❯   React</b>
    Preact
    Lit
    Svelte
    Solid
    Qwik
    Angular
    Others</code></pre>
<p>You can choose your favourite variant, but I will keep things simple
and select plain <code>JavaScript</code></p>
<pre class="language-bash"><code class="language-bash">✔ Select a framework: › React
? Select a variant: › - Use arrow-keys. Return to submit.
    TypeScript
    TypeScript + SWC
<b>❯   JavaScript</b>
    JavaScript + SWC
    Remix ↗</code></pre>
<ol start="6" type="1">
<li>Make your choice</li>
</ol>
<p>Vite will now get busy and create a default set of files and folders
in your <code>frontend/</code> directory. When it has finished, your
project folder should have a structure like this:</p>
<pre class="language-bash"><code class="language-bash">.
├── backend
│   ├── node_modules/
│   ├── package-lock.json
│   ├── package.json
│   ├── public/
│   └── server.js
│
├── frontend
│   ├── README.md
│   ├── eslint.config.js
│   ├── index.html
│   ├── package.json
│   ├── public
│   │   └── vite.svg
│   ├── src
│   │   ├── App.css
│   │   ├── App.jsx
│   │   ├── assets
│   │   │   └── react.svg
│   │   ├── index.css
│   │   └── main.jsx
│   └── vite.config.js
│
├── package.json
└── publish.sh</code></pre>
<p>Your Terminal will tell you what to do next:</p>
<pre class="language-bash"><code class="language-bash">Scaffolding project in /path/to/MyProject/frontend...

Done. Now run:

  npm install
  npm run dev</code></pre>
<ol start="7" type="1">
<li>Run <code>npm i &amp;&amp; npm run dev</code>, instead of what Vite
suggests</li>
</ol>
<details class="note" open>
<summary>
&amp;&amp;
</summary>
<p>This single line has the same effect as the two suggested lines. In
<code>bash</code>, the <code>&amp;&amp;</code> operator means “don’t run
the second command unless the first command completed successfully”.
This is different from what <code>&amp;&amp;</code> means in JavaScript,
but sometimes it can have the same effect. You can read more about this
<a href="https://ioflood.com/blog/bash-and-operator/">here</a>.</p>
<p>Remember this trick. You’ll be using it again shortly.</p>
</details>
<p>Vite should start its own built-in development server which listens
on port 5173 by default. If you have another Vite project running, then
the port number may be different.</p>
<pre class="language-bash"><code class="language-bash">VITE v5.4.11  ready in 343 ms

  ➜  Local:   http://localhost:5173/
  ➜  Network: use --host to expose
  ➜  press h + enter to show help</code></pre>
<ol start="8" type="1">
<li>Press the <code>Ctl</code> key (or <code>Cmd</code> if you are
working on a Mac) and at the same time click on the link
<code>http://localhost:5173</code>. Your favourite browser should open a
new tab and show the default Vite web page.</li>
</ol>
<figure>
<img src="images/vite5173.webp"
alt="The Vite development server running on port 5173" />
<figcaption aria-hidden="true">The Vite development server running on
port 5173</figcaption>
</figure>
<p>If you’ve worked with Vite before, this should be no surprise.</p>
<p>The next step will be to use your very own Express server to serve
the exact same content.</p>
</section>
<!-- Serving React with Express -->
<section id="serving-react-with-express" aria-labelledby="serving-react-with-express" data-item="Serving With Express">
<h2>
<a href="#serving-react-with-express">Serving React With Express</a>
</h2>
<p>Now you want to see the same site served from your Express server,
running on port 3000. This is the sight you want to see:</p>
<figure>
<img src="images/vite3000.webp"
alt="The React frontend served by your Express server" />
<figcaption aria-hidden="true">The React frontend served by your Express
server</figcaption>
</figure>
<p>Note that the URL in the address bar is <a
href="http://localhost:3000.">http://localhost:3000</a></p>
<p>I’ll explain first how to achieve this result manually, step-by-step,
and then I’ll show you how to automate it.</p>
<ol type="1">
<li>Ensure that your Terminal window is active in the
<code>frontend/</code> directory,</li>
<li>Run the command <code>npm run build</code></li>
</ol>
<pre class="language-bash"><code class="language-bash">$ npm run build

&gt; frontend@0.0.0 build
&gt; vite build

vite v5.4.11 building for production...
✓ 34 modules transformed.
dist/index.html                   0.46 kB │ gzip:  0.29 kB
dist/assets/react-CHdo91hT.svg    4.13 kB │ gzip:  2.14 kB
dist/assets/index-n_ryQ3BS.css    1.39 kB │ gzip:  0.72 kB
dist/assets/index-C-w0ssRA.js   143.20 kB │ gzip: 46.03 kB
✓ built in 355ms</code></pre>
<ol start="3" type="1">
<li>Check that there is now a <code>dist/</code> directory in your
<code>frontend/</code> directory. Run <code>ls -1F</code></li>
</ol>
<pre class="language-bash"><code class="language-bash">ls -1F
README.md
<b>dist/</b>
eslint.config.js
index.html
node_modules/
package-lock.json
package.json
public/
src/
vite.config.js</code></pre>
<ol start="4" type="1">
<li>In the Terminal, run <code>cd ..</code> to navigate to the parent
folder</li>
<li>Run <code>npm run publish</code>.</li>
</ol>
<p>Your <code>publish.sh</code> script should run, and copy all the
files</p>
<pre class="language-bash"><code class="language-bash">$ npm run publish

&gt; myproject@1.0.0 publish
&gt; ./publish.sh

About to sync files from ./frontend/dist/ to ./backend/public/
building file list ... done
./
index.html
vite.svg
assets/
assets/index-C-w0ssRA.js
assets/index-n_ryQ3BS.css
assets/react-CHdo91hT.svg

sent 151122 bytes  received 142 bytes  302528.00 bytes/sec
total size is 150669  speedup is 1.00
Files successfully synced.</code></pre>
<ol start="6" type="1">
<li>Refresh the browser window that is connected to your Express server
at <code>http://localhost:3000</code>.</li>
</ol>
<p>You should see the Vite default page, just like in the image
above.</p>
<p>This took more steps than necessary. With a few simple changes to the
<code>package.json</code> file in the parent directory, you can reduce
it to one.</p>
</section>
<!-- Automating the workflow -->
<section id="automating-the-workflow" aria-labelledby="automating-the-workflow" data-item="Automated Workflow">
<h2>
<a href="#automating-the-workflow">Automating The Workflow</a>
</h2>
<p>Earlier, when you ran <code>npm run publish</code>, your
<code>publish.sh</code> script synchronized the files between
<code>frontend/dist/</code> and <code>backend/public/</code>. However,
to create and populate the <code>frontend/dist/</code> directory with
the files created by Vite, you had to run <code>npm run build</code>
from the <code>frontend/</code> folder manually.</p>
<p>Can you guess how you can change the <code>"scripts"</code> block in
the <code>package.json</code> file in the parent folder, so that you can
do both actions at once?</p>
<p>Here’s what the <code>"scripts"</code> block in the
<code>package.json</code> file in the parent folder looks like now:</p>
<pre class="language-json line-numbers" data-start="5"><code class="language-json line-numbers">  "scripts": {
    "backend": "npm --prefix ./backend start",
    "start": "npm run backend",
    "publish": "./publish.sh"
  },</code></pre>
<p>And here’s what the <code>"scripts"</code> block in the
<code>package.json</code> file that Vite created for you in the
<code>frontend/</code> folder looks like:</p>
<pre class="language-json line-numbers" data-start="6"><code class="language-json line-numbers">  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },</code></pre>
<p>What you want to do is run a single command in the Terminal when it
is active in the parent folder that will:</p>
<ul>
<li><p>Tell the <code>frontend/</code> to run the <code>"build"</code>
command, to regenerate the <code>frontend/dist/</code> directory</p>
<p>and then</p></li>
<li><p>Tell the <code>publish.sh</code> to run</p></li>
</ul>
<details class="challenge" open>
<summary>
Editing <code>MyProject/package.json</code>
</summary>
<ol type="1">
<li>Open the file at <code>MyProject/package.json</code></li>
<li>Take a look at the <code>"backend"</code> script:</li>
</ol>
<pre class="language-json line-numbers" data-start="6"><code class="language-json line-numbers">"npm --prefix ./backend start"</code></pre>
<ol start="3" type="1">
<li>You can use this pattern to call <code>build</code> in the
frontend:</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">"npm --prefix ./frontend run build"</code></pre>
<ol start="4" type="1">
<li>Edit the current <code>"publish"</code> script to run the
<code>"build"</code> script first and then the <code>publish.sh</code>
script.</li>
</ol>
<details class="hint" open>
<summary>
Hint
</summary>
<p>Earlier you ran <code>npm i &amp;&amp; npm run dev</code> to install
all the Vite dependencies and then start the Vite development server. As
you may recall, the <code>&amp;&amp;</code> operator ensures that the
first process is completed successfully before the second process
starts.</p>
</details>
<details class="solution" open>
<summary>
Solution
</summary>
<pre class="language-json line-numbers" data-start="6"><code class="language-json line-numbers">  <i>"scripts": {
    "backend": "npm --prefix ./backend start",
    "start": "npm run backend",
    </i><b>"build": "npm --prefix ./frontend run build",
    "publish": "npm run build && ./publish.sh"</b><i>
  },</i></code></pre>
</details>
</details>
</section>
<!-- Testing the publish script -->
<section id="testing-the-publish-script" aria-labelledby="testing-the-publish-script" data-item="Test the New Script">
<h2>
<a href="#testing-the-publish-script">Testing your New Version of
<code>publish</code> </a>
</h2>
<p>To check that <code>npm run publish</code> will perform both the
<code>build</code> and the <code>publish</code> actions:</p>
<ol type="1">
<li>With your Terminal window active in the parent folder, delete the
entire contents of the <code>backend/public/</code> directory:</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">rm -r backend/public/*</code></pre>
<p>The Terminal will ask you to type <code>y</code> (for “yes”) to
confirm that you really want to do this</p>
<pre class="language-bash wrap"><code class="language-bash wrap">$ rm -r backend/public/* 
sure you want to delete all 3 files in /path/to/backend/public [yn]? </code></pre>
<p>If you refresh the browser page that is connected to <a
href="http://localhost:3000/">http://localhost:3000/</a>, you should now
see <code>Cannot GET /</code>, because there is nothing in the
<code>backend/public/</code> directory.</p>
<ol type="1">
<li>Run a similar command to empty the <code>frontend/dist/</code>
directory:</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">rm -r frontend/dist/*</code></pre>
<ol start="2" type="1">
<li>Run <code>npm run publish</code></li>
</ol>
<p>The Terminal should show you lots of activity:</p>
<pre class="language-bash"><code class="language-bash">$ publish
&gt; npm run build && ./publish.sh


&gt; myproject@1.0.0 build
&gt; npm --prefix ./frontend run build


&gt; frontend@0.0.0 build
&gt; vite build

vite v5.4.11 building for production...
✓ 34 modules transformed.
dist/index.html                   0.46 kB │ gzip:  0.29 kB
dist/assets/react-CHdo91hT.svg    4.13 kB │ gzip:  2.14 kB
dist/assets/index-n_ryQ3BS.css    1.39 kB │ gzip:  0.72 kB
dist/assets/index-C-w0ssRA.js   143.20 kB │ gzip: 46.03 kB
✓ built in 357ms
About to sync files from ./frontend/dist/ to ./backend/public/
building file list ... done
./
index.html
vite.svg
assets/
assets/index-C-w0ssRA.js
assets/index-n_ryQ3BS.css
assets/react-CHdo91hT.svg

sent 151122 bytes  received 142 bytes  302528.00 bytes/sec
total size is 150669  speedup is 1.00
Files successfully synced.</code></pre>
<ol start="3" type="1">
<li>Refresh the browser page that is connected to <a
href="http://localhost:3000/">http://localhost:3000/</a>.</li>
</ol>
<p>You should now see the default Vite page again.</p>
<details class="pivot" open>
<summary>
Are we done yet?
</summary>
<p>It looks like you could stop here. Now you can simply develop your
frontend with Vite and React, and run <code>npm run publish</code> when
you are getting ready to deploy. But this is only true if:</p>
<ul>
<li>Your frontend will not make any API requests to the backend (but why
would you even <em>want</em> to use a backend if you don’t make any API
requests to it?)</li>
<li>Your frontend will not use React-Router to navigate to pages which
only the frontend knows about.</li>
</ul>
<p>If <em>both</em> of these statements are true then you can skip
forward to the section <a href="#deploy-to-render-com">43.
Deploying</a>.</p>
<p>If not… continue to the next section.</p>
</details>
</section>
<!-- Treating an API request -->
<section id="treating-an-api-request" aria-labelledby="treating-an-api-request" data-item="An API Request">
<h2>
<a href="#treating-an-api-request">Treating An API Request</a>
</h2>
<p>When I first start working on a backend project, I like to create a
simple <code>/ping</code> route that will return:</p>
<ul>
<li>Information about where the request came from</li>
<li>The address of the server that received it</li>
<li>The current time and date</li>
</ul>
<p>This gives me a sanity check that my backend is up and running and
responding to requests.</p>
<ol type="1">
<li>In <code>backend/</code>, create a script called
<code>router.js</code></li>
<li>Paste in the code from the code listing below. Take a few minutes to
see if you can understand what it does. But no worries: I’ll explain in
detail in a moment.</li>
</ol>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">/**
 * backend/router.js
 */

const { Router } = require('express')
const router = Router()

router.get("/ping", ping)

module.exports = router

function ping(req, res) {
  const { protocol, path, ip } = req
  const { host, referer, origin } = req.headers
  
  const message = `Connection from
referer ${referer}
origin  ${origin}
ip      ${ip}
for     ${protocol}://${host}${path}
at      ${Date()}`

  console.log(message);

  if (res) {
    res.send(`&lt;pre&gt;${message}&lt;/pre&gt;`)
  }
}</code></pre>
<ol start="3" type="1">
<li>Update your <code>server.js</code> script as shown in Listing 38
below:</li>
</ol>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers"><i>/**
 * server.js
 */

const express = require('express')
</i><b>const router = require('./router')</b><i>
const PORT = 3000

const server = express()
server.use(express.static('public'));

</i><b>server.use('/', router)</b><i>

server.listen(PORT, () =&gt; {
  console.log(`Server listening at http://localhost:${PORT}`)
})</i></code></pre>
<ol start="3" type="1">
<li>In a browser window, visit <a
href="http://localhost:3000/ping">http://localhost:3000/ping</a></li>
</ol>
<p>Well, that’s disappointing.</p>
<figure>
<img src="images/cannotGetPing.webp" alt="Cannot GET /ping" />
<figcaption aria-hidden="true">Cannot GET /ping</figcaption>
</figure>
</section>
<!-- Understanding router.js -->
<section id="understanding-router-js" aria-labelledby="understanding-router-js" data-item="Inside router.js">
<h2>
<a href="#understanding-router-js">Understanding the
<code>router.js</code> script</a>
</h2>
<p>Before I show you how to fix this issue, I want to walk through the
<code>router.js</code> script to make sure that it is clear what it
does. (And yes, I’ve got this exact script working on my development
computer. The problem is not in the script itself, and it’s simple to
fix.)</p>
<p>Here’s the <code>router.js</code> script again, for reference:</p>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">/**
 * backend/router.js
 */

const { Router } = require('express')
const router = Router()

router.get("/ping", ping)

module.exports = router


function ping(req, res) {
  const { protocol, path, ip } = req
  const { host, referer, origin } = req.headers
  
  const message = `Connection from
referer ${referer}
origin  ${origin}
ip      ${ip}
for     ${protocol}://${host}${path}
at      ${Date()}`

  console.log(message);

  if (res) {
    res.send(`&lt;pre&gt;${message}&lt;/pre&gt;`)
  }
}</code></pre>
<p>Line 5 uses a <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">deconstructing
assignment</a> to load the <code>Router</code> function which is one of
the properties of the Express object.</p>
<p>You can think of the <code>Router</code> function as a black box
which makes good things happen, without you having to understand how,
just like your phone makes good things happen without you having to
understand <em>what</em> it is doing.</p>
<p>Basically, Express Router allows you to connect a requests from a
specific <em>endpoint</em> (like <code>/ping</code>) to a function that
will respond to that request.</p>
<p>Line 6 creates an instance from the <code>Router</code> function. I
have unimaginatively called this: <code>router</code>. You can find
details about <a
href="https://expressjs.com/en/guide/routing.html#express-router">express.Router
in the official documentation</a>.</p>
<p>Line 8 tells the <code>router</code> instance to respond to a request
for the <code>/ping</code> route by using the <code>ping</code> function
as a callback. I’ll describe the <code>ping</code> function in more
detail below.</p>
<p>Line 10 makes this <code>router</code> instance available to any
script that wants to use it.</p>
<details class="note" open>
<summary>
module.exports
</summary>
<p>If you are not familiar with the <code>module.exports</code> syntax,
there’s a good <a
href="https://www.sitepoint.com/understanding-module-exports-exports-node-js/#whatsthedifferencebetweenmoduleexportsandexports">article
on SitePoint.com</a> that explains it in depth.</p>
</details>
<h2 id="how-server.js-interacts-with-router.js">How
<code>server.js</code> interacts with <code>router.js</code></h2>
<p>The lines that you just added to <code>server.js</code>: 1. Loads in
the new <code>router.js</code> file 2. <code>use</code>s it to control
how any requests for specific API routes are handled.</p>
<pre class="language-js line-numbers" data-start="6"><code class="language-js line-numbers"><b>const router = require('./router')</b><i>
const PORT = 3000

const server = express()
server.use(express.static('public'));

</i><b>server.use('/', router)</b></code></pre>
In other words, the <code>server.js</code> script gets to outsource some
of its functionality to the <code>router.js</code> script. This lets you
keep your code neat and tidy, with each script specializing in one
thing.
</section>
<!-- The ping function -->
<section id="the-ping-function" aria-labelledby="the-ping-function" data-item="The ping Function">
<h2>
<a href="#the-ping-function">The <code>ping</code> Function</a>
</h2>
<p>So what does <code>server.get("/ping", ping)</code> do?</p>
<details class="note" open>
<summary>
Full details
</summary>
<p>You can find the full details about route handlers like the
<code>get</code> method in the <a
href="https://expressjs.com/en/guide/routing.html#route-handlers">Express
documentation</a>.</p>
</details>
<p>In short: when your server receives a request from a client (such as
your browser), Express will generate two objects that allow your server
to handle the request. These two objects that are passed as parameters
to the callback are conventionally called <code>req</code> (request) and
<code>res</code> (response).</p>
<p>The callback function in this case is <code>ping</code>, and so it
starts by reading in these objects</p>
<pre class="language-js line-numbers" data-start="13"><code class="language-js line-numbers">function ping(req, res) {</code></pre>
<pre class="skip"><code class="skip">// lines skipped</code></pre>
<pre class="language-js line-numbers" data-start="29"><code class="language-js line-numbers">}</code></pre>
<p>When you make a request for <a
href="http://localhost:3000/ping">http://localhost:3000/ping</a>, the
<code>path</code> part of the URL you requested is <code>/ping</code>,
and the <code>server.get()</code> method associates this path with this
<code>ping</code> function.</p>
<h2 id="reading-values-from-req">Reading values from
<code>req</code></h2>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<tbody>
<tr>
<td>req</td>
<td>is an instance of <a
href="https://nodejs.org/api/http.html#class-httpclientrequest">http.ClientRequest</a>.
It contains data from the browser, and also information about the
browser and the operating system on which it is running.</td>
</tr>
<tr>
<td>res</td>
<td>is an instance of <a
href="https://nodejs.org/api/http.html#class-httpserverresponse">http.ServerResponse</a>.
It contains methods which can be used to send data back to the
browser.</td>
</tr>
</tbody>
</table>
<details class="tldr">
<summary>
The <code>req</code> object
</summary>
<p>The <code>req</code> object is very complex. If you want to see
<em>how</em> complex (but you really don’t):</p>
<ol type="1">
<li>Add the following route to your <code>router.js</code> script:</li>
</ol>
<pre class="language-js line-numbers"><code class="language-js line-numbers">router.get("/req", (req, res) =&gt; {
  res.send(`&lt;pre&gt;
${require("util").inspect(req)}
  &lt;/pre&gt;`)
})</code></pre>
<ol type="1">
<li>Stop your backend server (type <code>^C</code> in the Terminal where
the server is running)</li>
<li>Restart it with <code>npm start</code></li>
<li>Visit <a
href="http://localhost:3000/req">http://localhost:3000/req</a></li>
</ol>
<p>Over 600 lines of data. Too much information? So much output from
such a cute little route. Don’t say I didn’t warn you. And even if you
search through all that data, you won’t find the protocol value of
<code>"http"</code> anywhere. This value is returned by a getter
function if you ask for it directly. And <code>inspect()</code> method
of the <code>util</code> module doesn’t ask.</p>
<details class="question" open>
<summary>
Bonus!
</summary>
<p>If you follow all these steps, then when you visit <a
href="http://localhost:3000/ping">http://localhost:3000/ping</a> the
problem <code>Cannot GET /ping</code> will have magically disappeared.
Can you see why?</p>
</details>
</details>
<p>Just trust me that the key information that you need from the
<code>req</code> object is:</p>
<pre class="language-js line-numbers" data-start="14"><code class="language-js line-numbers">  const { protocol, path, ip } = req
  const { host, referer, origin } = req.headers</code></pre>
<p>This reads three values directly from the <code>req</code>
object:</p>
<ul>
<li>The <code>protocol</code>, which will be <code>http</code>(in this
case) or the secure value <code>https</code></li>
<li>The <code>path</code> that your browser requested (in this case
<code>/ping</code>)</li>
<li>The <code>ip</code> address of the computer making the request. In
this case, you’ll probably see <code>::ffff:127.0.0.1</code>. You’ll
recognize <code>127.0.0.1</code> as the IP address for the
<code>localhost</code> of your computer. The value you’ll see is what’s
called an <em>IPv4-mapped IPv6 address</em>. In a way, it’s like adding
“The World” to the end of your postal address. The
<code>127.0.0.1</code> is the part that is useful for you.</li>
</ul>
<p>It then reads three more values from the <code>headers</code> that
were sent by your browser:</p>
<ul>
<li>The <code>host</code>, or the server that the request was sent to.
This includes the port, the domain and any subdomains. In this case:
<code>http://localhost:3000</code></li>
<li>The <code>referer</code> header is only added if the browser is
sending a request from inside a web page. You’ll be using
<code>fetch()</code> to do this shortly, but for now, the
<code>referer</code> will be <code>undefined</code></li>
<li>The <code>origin</code> header is only added if the
<code>referer</code> is not <code>undefined</code> and refers to a
different <code>host</code> than the request is made to. The
<code>origin</code> header can be used by the server to decide whether
it wants to deal with requests from a third-party site.</li>
</ul>
<details class="tip" open>
<summary>
Making a <code>Date()</code>
</summary>
<p>JavaScript’s built-in <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date()</code>
function</a> returns an object which, when rendered as a string,
gives:</p>
<ul>
<li>The day of the week</li>
<li>The month</li>
<li>The day of the month</li>
<li>The year</li>
<li>The time to the nearest second</li>
<li>The time zone</li>
<li>The name of the time zone</li>
</ul>
<p>Each time you call the <code>Date()</code> function, it will give a
different value, so it’s a good way of checking whether your browser is
showing you fresh data or something that it cached for you earlier.</p>
</details>
<h3 id="sending-a-response-with-res.send">Sending a response with
<code>res.send()</code></h3>
<p>So, if all were going well, the <code>ping()</code> function would
create a string that looks something like this:</p>
<pre class="language-bash wrap"><code class="language-bash wrap">Connection from
referer undefined
origin  undefined
ip      ::ffff:127.0.0.1
for     http://localhost:3000/ping
at      Tue Nov 19 2024 11:11:38 GMT+0100 (Central European Standard Time)</code></pre>
<p>It would log this into the Terminal Console, and then call the
<code>res.send()</code> method of the <code>res</code> (response) object
to send this string back to your browser.</p>
<p>You can read more about the different methods of the <code>res</code>
object <a
href="https://www.digitalocean.com/community/tutorials/nodejs-res-object-in-expressjs">here</a>.</p>
<details class="pivot" open>
<summary>
Getting <code>ping()</code> to work
</summary>
<p>But the <code>ping()</code> function did not do that, for a very
simple reason that you have perhaps already guessed.</p>
</details>
</section>
<!-- Restarting the Server -->
<section id="restarting-the-server" aria-labelledby="restarting-the-server" data-item="Restarting The Server">
<h2>
<a href="#restarting-the-server">Restarting The Server</a>
</h2>
<p>When you started your server, you told <code>node</code> to run the
<code>server.js</code> script. So <code>node</code> cached a copy of the
script, and started running that. You have changed the contents of the
<em>file</em> <code>server.js</code>, but <code>node</code> doesn’t know
that, and so it cannot apply your changes.</p>
<p>Here’s the quickest way to get the <code>/ping</code> endpoint to
work:</p>
<ol type="1">
<li>Open the Terminal window where you launched the server with
<code>npm start</code></li>
<li>Press <code>^C</code> (Ctl-C) to stop the server.</li>
<li>Press the Up Arrow key on your keyboard. The command
<code>npm start</code> should reapper.</li>
<li>Press Enter</li>
<li>In your browser visit the page that shows the site served by the
Express server (which is currently showing
<code>Cannot GET /ping</code>)</li>
<li>Refresh the page.</li>
</ol>
<p>You should see something like this:</p>
<figure>
<img src="images/pingInAction.webp"
alt="A request for /ping now receives the expected data" />
<figcaption aria-hidden="true">A request for /ping now receives the
expected data</figcaption>
</figure>
<p>The date, time and location may be different for you.</p>
<details class="note" open>
<summary>
Did you check <code>/req</code> earlier?
</summary>
<p>If you manually restarted the server to test the <a
href="http://localhost:3000/req">http://localhost:3000/req</a> path,
then the <code>/ping</code> path will have started working at the same
time for the same reason.</p>
</details>
</section>
<!-- Using nodemon -->
<section id="using-nodemon" aria-labelledby="using-nodemon" data-item="Using nodemon">
<h2>
<a href="#using-nodemon"><code>nodemon</code> to the rescue!</a>
</h2>
<p>The good news is that there is a Node package called <a
href="https://www.npmjs.com/package/nodemon"><code>nodemon</code></a>(and
<a href="https://www.npmjs.com/package/nodemon#pronunciation">you can
pronounce this any way you want</a>), which will watch your files and
restart your NodeJS app if any of your the files in your project
change.</p>
<p>You will probably want to use this for all your projects, so you can
install it globally. with the following command:</p>
<pre class="language-bash wrap"><code class="language-bash wrap">npm install -g nodemon</code></pre>
<p>The <code>-g</code> flag means “globally”.</p>
<p>When you have done that, you can edit your file at
<code>backend/package.json</code> so that the <code>"start"</code>
script uses <code>nodemon</code> instead of <code>node</code>:</p>
<pre class="language-json line-numbers"><code class="language-json line-numbers">{
  "dependencies": {
    "express": "^4.21.1"
  },
  "scripts": {
    "start": "nodemon server.js"
  }
}</code></pre>
<p>Now you can stop and restart your server:</p>
<ol type="1">
<li>Open the Terminal window where you originally ran
<code>npm start</code></li>
<li>Press <code>^C</code> (Ctl-C) to cancel the current process</li>
<li>Run <code>npm start</code> again, to relaunch your server using
<code>nodemon</code>.</li>
</ol>
<pre class="language-bash line-numbers"><code class="language-bash line-numbers">$ ^C
$ npm start
&gt; npm run backend


&gt; myproject@1.0.0 backend
&gt; npm --prefix ./backend start


&gt; start
&gt; nodemon server.js

[nodemon] 3.1.7
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,cjs,json
[nodemon] starting `node server.js`
Server listening at http://localhost:3000</code></pre>
<ol start="4" type="1">
<li>Make a cosmetic change to the <code>ping()</code> function (adding a
colon), just to test whether <code>nodemon</code> is doing its job:</li>
</ol>
<pre class="language-javascript line-numbers" data-start="13"><code class="language-javascript line-numbers"><i>function ping(req, res) {
  const { protocol, path, ip } = req
  const { host, referer, origin } = req.headers
  
  const message = `Connection </i><b>from:</b><i>
referer ${referer}
origin  ${origin}
ip      ${ip}
for     ${protocol}://${host}${path}
at      ${Date()}`</i></code></pre>
<ol start="5" type="1">
<li>Visit <code>http://localhost:3000/ping</code></li>
</ol>
<p>You should see the colon appear:</p>
<figure>
<img src="images/pingColon.webp"
alt="nodemon restarted the server, so it is running the latest code" />
<figcaption aria-hidden="true"><code>nodemon</code> restarted the
server, so it is running the latest code</figcaption>
</figure>
<details class="question" open>
<summary>
http://localhost:3000/ping is working but…
</summary>
<p>… isn’t this a problem?</p>
<p>Do you see that this is a problem? If I tell you that this
<em>is</em> a problem, can you work out what the problem is?</p>
<p>It should all become clear after you edit your frontend to access
this API endpoint.</p>
</details>
</section>
<!-- Accessing the API from the frontend -->
<section id="accessing-the-api-from-the-frontend" aria-labelledby="accessing-the-api-from-the-frontend" data-item="Frontend API Access">
<h2>
<a href="#accessing-the-api-from-the-frontend">Accessing The API From
The Frontend</a>
</h2>
<p>Vite automatically creates a placeholder page for you that
demonstrates some minimal React interactivity. My first step in any
project is to tear this out and replace it with something that does
something interesting.</p>
<p>For this project, sending a request to <code>/ping</code> is
something interesting. To do that, you’ll need to create a new script
and make changes to two others.</p>
<ol type="1">
<li>Create a new script at <code>frontend/src/components/Ping.jsx</code>
with the code from the listing below.</li>
</ol>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">/**
 * frontend/src/components/Ping.jsx
 */

import React, { useState } from 'react'

export const Ping = () =&gt; {
  const [ response, setResponse ] = useState("")
  
  const getPing = () =&gt; {
    fetch(`/ping`)
      .then(incoming =&gt; incoming.text())
      // WARNING: text really should be sanitized, but not yet
      .then(text =&gt; setResponse(text))
  }
  
  return (
    &lt;&gt;
      &lt;button
        onClick={getPing}
      &gt;
        GET /ping
      &lt;/button&gt;
      &lt;pre&gt;
        {response}
      &lt;/pre&gt;
    &lt;/&gt;
  )
}</code></pre>
<ol start="2" type="1">
<li>Replace the contents of <code>frontend/src/App.jsx</code> with the
code below.</li>
</ol>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers">/**
 * frontend/src/App.jsx
 */
 
import './App.css'
import { Ping } from './components/Ping'

function App() {
  return (
    &lt;&gt;
      &lt;Ping/&gt;
    &lt;/&gt;
  )
}

export default App</code></pre>
<ol start="3" type="1">
<li>Replace the contents of <code>frontend/src/App.css</code> with the
styles shown below:</li>
</ol>
<pre class="language-css line-numbers"><code class="language-css line-numbers">/**
 * frontend/src/App.css
 */

pre {
  border: 1px inset #888;
  width: fit-content;
  min-width: 25em;
  min-height: 7em;
  overflow: auto;
}</code></pre>
<details class="note" open>
<summary>
More explanations needed?
</summary>
<p>I’m going to assume that you are already sufficiently familiar with
React and <code>fetch()</code> and <code>Promises</code> to understand
what is going on in these scripts. If not, click on Feedback link in the
hamburger Menu on the left, and let me know.</p>
</details>
<ol start="4" type="1">
<li><p>In the Terminal window where the parent folder is active, run the
command…</p>
<pre class="language-bash wrap"><code class="language-bash wrap">npm run publish</code></pre>
<p>… to update the files in the <code>backend/public/</code>
directory.</p></li>
<li><p>Visit <code>http://localhost:3000</code>, which
<code>nodemon</code> should have restarted for you. (Note: this URL does
not include the <code>/ping</code> path)</p></li>
<li><p>You should see your custom React page, with a
<code>GET /ping</code> button. Click on <code>GET /ping</code>.</p></li>
</ol>
<p>You should see something like this:</p>
<figure>
<img src="images/localping.webp"
alt="When backend/public/index.html makes a request for the /ping endpoint" />
<figcaption aria-hidden="true">When
<code>backend/public/index.html</code> makes a request for the
<code>/ping</code> endpoint</figcaption>
</figure>
<p>Notice how the value for <code>referer</code> is now set, because the
request came from a script inside the page loaded from <a
href="http://localhost:3000/">http://localhost:3000/</a>. However, the
browser did not send an <code>origin</code> header, because the
<code>referer</code> has the same host as the server to which the
request is being made.</p>
<details class="note" open>
<summary>
The <code>&lt;pre&gt;</code> element
</summary>
<p>There are <code>&lt;pre&gt; ... &lt;/pre&gt;</code> tags around the
output. This is because <code>server.js</code> is sending a
pre-formatted HTML string, so that a direct request for
[http://localhost:3000/ping] will look good in the browser.</p>
<p><strong>In production, you should never use
<code>element.innerHTML = &lt;some unverified string&gt;</code></strong>,
because a malicious actor could include executable code in it. This is a
reminder of the need to sanitize data from any unreliable source before
you use it. I’ve left the incoming string untouched for now because, in
the next step, the value you receive will not be what you expect, and it
will be helpful to see it all.</p>
<p>It’s OK. This is happening under your control, in development mode,
so nothing bad will happen.</p>
</details>
<details class="pivot" open>
<summary>
What about that <em>other</em> problem though?
</summary>
<p>At the end of the last section, I suggested there was a problem with
the result of a direct request for <a
href="http://localhost:3000/ping">http://localhost:3000/ping</a>. Do you
see that problem yet?</p>
<p>What you see now is the same kind of data that you saw earlier, when
you accessed <a
href="http://localhost:3000/ping">http://localhost:3000/ping</a>
directly. That’s good isn’t it? You <em>should</em> get the same data
through the frontend client app <em>and</em> through direct access,
shouldn’t you? Or shouldn’t you?</p>
</details>
</section>
<!-- Vite has other ideas -->
<section id="vite-has-other-ideas" aria-labelledby="vite-has-other-ideas" data-item="Vite Has Other Ideas">
<h2>
<a href="#vite-has-other-ideas">Vite Has Other Ideas</a>
</h2>
<p>When you are developing your app, you don’t want to have to run
<code>npm run publish</code> after every change. If you’ve worked with
Vite before at all, you will have got used to the idea that Vite uses <a
href="https://dev.to/debajit13/the-magic-of-hot-reloading-in-react-5d48">hot
reloading</a> to update the code in your browser each time you save a
changed file. I’m guessing that you want to continue working that way in
this project, too.</p>
<p>If you ran <code>npm run dev</code> to get Vite start your frontend
development server, you should still be able to visit
http://localhost:5173/, where you will see the same
<code>GET /ping</code> button that was served from your Express
server.</p>
<details class="tip" open>
<summary>
Restart the Vite development server if necessary
</summary>
<p>If necessary, open a Terminal window on your <code>frontend/</code>
directory, and run <code>npm run dev</code>, then Ctrl- or Cmd- click on
the link that is displayed.</p>
</details>
<ol type="1">
<li>Visit http://localhost:5173/</li>
<li>Click on the <code>GET /ping</code> button.</li>
</ol>
<p>The results will be rather different from what you might expect:</p>
<figure>
<img src="images/viteping.webp"
alt="The result of GET /ping received by the frontend" />
<figcaption aria-hidden="true">The result of GET /ping received by the
frontend</figcaption>
</figure>
<h2 id="what-is-vite-sending-you">What is Vite sending you?</h2>
<p>Not sanitizing the incoming string before setting the
<code>innerHTML</code> of the element means that you can see exactly
what string you receive.</p>
<p>Vite responds to a request for <code>/ping</code> with what seems to
be an HTML page. The
<code>&lt;title&gt;Vite + React&lt;/title&gt;</code> tag might give you
a clue as to what page this is.</p>
<p>Open <code>frontend/index.html</code> and compare it to what you see
in your browser. It’s the same page with a couple of scripts injected by
Vite. The scripts injected by Vite are highlighted below:</p>
<pre class="language-html line-numbers"><code class="language-html line-numbers"><i>&lt;!doctype html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    </i><b>&lt;script type="module"&gt;
import RefreshRuntime from "/@react-refresh"
RefreshRuntime.injectIntoGlobalHook(window)
window.$RefreshReg$ = () =&gt; {}
window.$RefreshSig$ = () =&gt; (type) =&gt; type
window.__vite_plugin_react_preamble_installed__ = true
&lt;/script&gt;

    &lt;script type="module" src="/@vite/client"&gt;&lt;/script&gt;</b><i>

    &lt;meta charset="UTF-8" /&gt;
    &lt;link rel="icon" type="image/svg+xml" href="/vite.svg" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;Vite + React&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="root"&gt;&lt;/div&gt;
    &lt;script type="module" src="/src/main.jsx?t=1736244164711"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</i></code></pre>
<details class="question" open>
<summary>
What can you conclude from this?
</summary>
<p>Whenever you make a request to the Vite development server, it will
respond with the <code>index.html</code> page, regardless of the path
that you use. Here, it responded as if your request had been for the
<code>/</code> path and not for <code>/ping</code>. The
<code>ping</code> part of the path was ignored.</p>
<p>This is how the Vite development server works, and it works this way
for a reason.</p>
<p><strong>Remember this, because you will be using this insight
later.</strong></p>
</details>
</section>
<!-- Where is the backend -->
<section id="where-is-the-backend" aria-labelledby="where-is-the-backend" data-item="Which backend?">
<h2>
<a href="#where-is-the-backend">Where is the backend for the Vite
development server?</a>
</h2>
<p>It’s not surprising that you didn’t get the same response that you
got from <a
href="http://localhost:3000/ping">http://localhost:3000/ping</a>,
because the Vite development server is running at <a
href="http://localhost:5173">http://localhost:5173</a>. Using
<code>fetch('/ping')</code> is asking for data at the wrong address.</p>
<p>How do you fix it so that it asks at the right address?</p>
<p>First, what <em>is</em> the right address? For now, the backend
server is running at <code>http://localhost:3000</code>, because that
value was hard-coded into <code>server.js</code>. When you are working
with a team, someone might be making changes to the backend while you
make changes to the frontend, and you want to be able to adapt as
quickly as possible, without searching through your code.</p>
<p>The answer is to create a file called <code>.env</code>. “env” is
short for <code>environment</code>, and the initial dot is to make this
file hidden from your operating system’s desktop.</p>
<p>In a <code>.env</code> file, you can set any variables which might
change (like the location of the backend server) or any information that
no-one else needs to know (like the secret keys for connecting to your
private database).</p>
<p>When Vite launches its development server, it will look for a
<code>.env</code> file and read in any variables whose name starts with
<code>VITE_</code>. This means that you can store other variables with
other names, and Vite won’t spy on them. The variables that start with
<code>VITE_</code> will be added to an object called
<code>import.meta.env</code>.</p>
<details class="note" open>
<summary>
<code>.env</code> with Vite and NodeJS
</summary>
<p>If you have used a <code>.env</code> file with NodeJS, you will know
that NodeJS can read variables from the file into its
<code>process.env</code> object. However, it doesn’t do this
automatically. Vite’s use of <code>.env</code> is different in three
ways:</p>
<ul>
<li>The <code>.env</code> file <em>is</em> read automatically</li>
<li>Only variables that start with <code>VITE_</code> are read in</li>
<li>These variables become accessible from the
<code>import.meta.env</code> object, not from
<code>process.env</code>.</li>
</ul>
</details>
<ol type="1">
<li>Create a file at <code>frontend/.env</code> — at the root of the
<code>frontend/</code> directory</li>
<li>Add this entry: <code>VITE_ORIGIN=http://localhost:3000</code></li>
<li>Edit the file at <code>frontend/src/components/Ping.jsx</code> so
that it matches the listing below:</li>
</ol>
<pre class="language-javascript line-numbers"><code class="language-javascript line-numbers"><i>/**
 * frontend/src/components/Ping.jsx
 */

import React, { useState } from 'react'
</i><b>const TAG_REGEX = /(&lt;.*?&gt;)|(&lt;\/.*?&gt;)/g
const ORIGIN = import.meta.env.VITE_ORIGIN
console.log("ORIGIN:", ORIGIN);</b><i>

export const Ping = () =&gt; {
  const [ response, setResponse ] = useState("")
  
  const getPing = () =&gt; {
    fetch(`</i><b>${ORIGIN}</b><i>/ping`)
      .then(incoming =&gt; incoming.text())
      </i><b>// Always sanitize data from unreliable sources
      .then(text =&gt; text.replace(TAG_REGEX, ""))
      .then(text =&gt; setResponse(text))
      .catch(error =&gt; setResponse(error.message))</b><i>
  }

  return (
    &lt;&gt;
      &lt;button
        onClick={getPing}
      &gt;
        GET /ping
      &lt;/button&gt;
      &lt;pre&gt;
        {response}
      &lt;/pre&gt;
    &lt;/&gt;
  )
}</i></code></pre>
<ol start="4" type="1">
<li>Note that this time:
<ul>
<li>A TAG_REGEX regular expression is declared</li>
<li>The incoming string <em>is</em> sanitized using this RegExp to
remove any embedded tags, such as a <code>&lt;script&gt;</code> tag
which could run arbitrary code without your knowledge.</li>
<li>There’s a <code>catch()</code> statement, just in case there is a
problem with the <code>fetch</code> command.</li>
</ul></li>
</ol>
</section>
<!-- Network error -->
<section id="network-error" aria-labelledby="network-error" data-item="Network Error?">
<h2>
<a href="#network-error">Network Error?</a>
</h2>
<p>When you refresh your link to <code>http://localhost:5173</code> in
your browser and click on the <code>GET /ping</code> button, you have a
different problem:</p>
<p><code>NetworkError while attempting to fetch resource.</code></p>
<p>Open the Console in the Developer Tools, to see what’s going on.</p>
<figure>
<img src="images/CORS.webp"
alt="The frontend server is at port 5173, the backend at port 3000: a CORS issue" />
<figcaption aria-hidden="true">The frontend server is at port 5173, the
backend at port 3000: a CORS issue</figcaption>
</figure>
<p>You have an issue with CORS.</p>
<p><strong><em>An issue with CORS?</em></strong></p>
<h3 id="what"><em>What?</em></h3>
<p>Didn’t I promise you right at the beginning that you wouldn’t have
any CORS issues with your production server?</p>
<p>Yes, but this is happening in your <em>development</em>
environment.</p>
<details class="pivot" open>
<summary>
Relaxing security
</summary>
<p>Your development environment is a safe place. In your safe
development environment, you can open up your development server to any
incoming request, knowing that those requests will only be coming from
trustworthy clients under your control. So the solution is simple.</p>
</details>
</section>
<!-- What CORS does -->
<section id="what-cors-does" aria-labelledby="what-cors-does" data-item="What CORS Does">
<h2>
<a href="#what-cors-does">What CORS Does</a>
</h2>
<p>Before explaining how to fix the problem with Cross Origin Resource
Sharing, it’s important to make something clear. The Express backend
<em>did</em> send the expected data to you browser. Here’s the proof, as
provided by Firefox v 133.0.3:</p>
<figure>
<img src="images/errorResponse.webp"
alt="Using Firefox’s Network tab to display the response received" />
<figcaption aria-hidden="true">Using Firefox’s Network tab to display
the response received</figcaption>
</figure>
<p>To see this for yourself, you’ll need to use Firefox. All other
browser that I’ve tried (Chrome, Safari, Edge, Opera) pretend that they
don’t know anything about the response:</p>
<ol type="1">
<li>Open <a
href="https://www.mozilla.org/en-US/firefox/new/">Firefox</a></li>
<li>Use it to visit h<a
href="http://localhost:5173/">ttp://localhost:5173/</a></li>
<li>Open the Developer tools</li>
<li>Select the Network tab</li>
</ol>
<details class="tip">
<summary>
No Network tab?
</summary>
<p>If you don’t immediately see a Network tab, you can:</p>
<ol type="1">
<li>Click on the three dots at the right end of the Developer Tools menu
bar</li>
<li>Select settings</li>
<li>Check the Network checkbox</li>
</ol>
<figure>
<img src="images/ShowNetwork.webp"
alt="A composite image to show the steps" />
<figcaption aria-hidden="true">A composite image to show the
steps</figcaption>
</figure>
</details>
<ol start="5" type="1">
<li>Click on the <code>GET /ping</code> button to initiate a
request</li>
<li>Click on the new line that appears in the Network pane</li>
<li>Click on the Response tab in the details pane that appears.</li>
</ol>
<h2 id="what-does-express-think-its-doing">What does Express think it’s
doing?</h2>
<p>I imagine that you might have a number of questions at this point.
Like:</p>
<ul>
<li>If the request came from an unauthorized origin, why did Express not
simply return something like <code>403 Unauthorized</code>?</li>
<li>Why did it both send the response <em>and</em> fail to send an
<code>Access-Control-Allow-Origin</code> header, so that your browser
refuses to give your <code>fetch()</code> request access to the
response?</li>
<li>Didn’t Express use more CPU cycles than necessary to handle a
request that the browser will refuse to treat?</li>
<li>Wasn’t this a waste of bandwidth?</li>
</ul>
<p>Express is designed to be <em>unopinionated</em>. It will respond to
any request that it is sent, using as much CPU energy as is required to
generate that response. It will also warn your well-behaved browser not
to use the response.</p>
<p>If <em>you</em> want to prevent Express from doing any work on
unauthorized requests, then that is <em>your</em> responsibility. And
you should take it.</p>
<h2 id="what-is-cors-access-control-allow-origin-header">What is CORS
<code>Access-Control-Allow-Origin</code> header?</h2>
<p>The purpose of CORS is to protect your browser (and you) from
malicious attacks. Suppose you are visiting a site that shows innocuous
funny cat pics, and while you are logged on you decide to visit your
bank’s web site. You fill in the authorization form, and the bank’s web
site sends an authentication code to your browser.</p>
<p>The not-so-innocuous funny cat pics web site now sends its own
request to your bank’s web site, with the authentication code that is
now stored in your browser. The bank’s site is not as well-designed as
it could be, and sends a response.</p>
<p>But the IP address of the funny cat pics web site is not white-listed
by the bank, so it <em>does not</em> send an
<code>Access-Control-Allow-Origin</code> header. As a result, the
JavaScript on the funny cat pics web site cannot access the response,
and your identity and bank account are still safe.</p>
<p>To be fair, bank web sites are likely to be hypersecure. I used a
bank as an example to give an idea of the gravity of the problem. The
stakes are not so high if you logged on to the latest social media web
site, but could be more embarrassing.</p>
</section>
<!-- Using CORS in development -->
<section id="using-cors-in-development" aria-labelledby="using-cors-in-development" data-item="CORS at Dev Time">
<h2>
<a href="#using-cors-in-development">Using CORS In Development</a>
</h2>
<p>It’s easy to add a NodeJS package that will handle Cross-Origin
Resource Sharing for you. The module is called <code>cors</code>.</p>
<ol type="1">
<li><p>Open a Terminal window that on your <code>backend/</code>
directory</p></li>
<li><p>Run the command…</p>
<pre class="language-bash wrap"><code class="language-bash wrap">npm i cors</code></pre>
<p>… just like you did when you installed Express. This will download
the <code>cors</code> package to your <code>node_modules</code>
directory.</p></li>
<li><p>Open <code>backend/server.js</code></p></li>
<li><p>Add the line of code highlighted in the listing below:</p></li>
</ol>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * server.js
 */

const express = require('express')
const router = require('./router')
const PORT = 3000

const server = express()
</i><b>server.use(require('cors')())</b><i>
server.use(express.static('public'));

server.use('/', router)

server.listen(PORT, () =&gt; {
  console.log(`Server listening at http://localhost:${PORT}`)
})</i></code></pre>
<p>With this new line your server is saying, in effect: “Anyone can make
a request, and I’ll answer and allow anyone to use my answer.”</p>
<p><code>nodemon</code> should restart your server automatically.
Refresh your link to <code>http://localhost:5173</code>, and click on
the <code>GET /ping</code> button again. You should see a successful
result like in Figure 25 below.</p>
<p>Notice how the request comes <code>from http://localhost:5173</code>
and is delivered <code>to   http://localhost:3000</code>.</p>
<figure>
<img src="images/gotPing.webp" alt="Successful /ping" />
<figcaption aria-hidden="true">Successful /ping</figcaption>
</figure>
<p>Notice how the value for <code>referer</code> is now set, because the
request came from a script inside the page loaded from <a
href="http://localhost:5173/">http://localhost:5173/</a>, and not from
<a href="http://localhost:3000/">http://localhost:3000/</a>. In
addition, the browser sent an <code>origin</code> header, because the
<code>referer</code> does not have the same host as the server to which
the request is being made.</p>
<p>Notice also that the <code>referer</code> ends with a <code>/</code>
slash character, but the <code>origin</code> does not.</p>
<details class="pivot" open>
<summary>
CORS in production
</summary>
<p>CORS is not designed to protect servers. CORS is designed to protect
browsers and end users.</p>
<p>The <code>cors</code> module does not tighten security. The
<code>cors</code> module allows less secure connections under specific
circumstances.</p>
<p>Next, you will be modifying the <code>server.js</code> script so that
it does not use the <code>cors</code> module in production. As a result,
it will use the tightest security. It will allow an end-user’s browser
to use data that it sends <em>only if</em> the request for the data came
from a script in a page loaded from your browser.</p>
</details>
</section>
<!-- No CORS in production -->
<section id="no-cors-in-production" aria-labelledby="no-cors-in-production" data-item="No Deployed CORS">
<h2>
<a href="#no-cors-in-production">No CORS In Production</a>
</h2>
<p>Adding the <code>cors</code> module, as you have just done, means
that anyone can gain access to your backend server. During development,
this is not a problem. You are not exposing your development backend to
the Bad Guys on the Internet.</p>
<h2 id="using-environment-variables">Using environment variables</h2>
<p>You want to make sure that the <code>cors</code> module does
<strong>not</strong> give anyone access to your backend when the server
is running in production mode. This means finding a way to tell your
backend server that it <strong><em>is</em></strong> running in
production mode. One conventional way of doing this is to add a hidden
<code>.env</code> file containing the string
<code>NODE_ENV=production</code>.</p>
<details class="tldr">
<summary>
Environment variables
</summary>
<p>The <code>.</code> dot in front of the file name will make your
operating system hide the file by default. Code editors like VS Code
know this, and they will allow you to see the file, even if your
operating system does not.</p>
<p>The string “env” in <code>.env</code> and <code>NODE_ENV</code> is
short for “environment”. Often the string <code>dev</code> or
<code>development</code> is used to describe the safe environment that
you work in as you are creating a project. For a secure production mode,
several different terms may be used, including</p>
<ul>
<li>production</li>
<li>prod</li>
<li>release</li>
<li>deploy</li>
<li>staging</li>
</ul>
<p>Note: <code>staging</code> is a half-way stage between development
and production. It’s an online environment that is not accessible to the
Internet at large, where a production-ready version of the site is
tested before it is official released.</p>
</details>
<h2 id="process.env"><code>process.env</code></h2>
<p>When you run a script using <code>node</code> (or
<code>nodemon</code>), NodeJS gathers together lots of information about
the environment you are working on. This includes, for example, the path
to the <code>node</code> executable that is running your script. This
information is made available in a global object called
<code>process.env</code>. To test this, you can make the following
temporary change to your <code>server.js</code> script.</p>
<ol type="1">
<li>Add a line at the very beginning of your <code>server.js</code>
script:</li>
</ol>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * server.js
 */

</i><b>console.log("process.env:", JSON.stringify(process.env, null, 2))
</b><i>
const express = require('express')
const router = require('./router')
const PORT = 3000

const server = express()
server.use(require('cors')())
server.use(express.static('public'));

server.use('/', router)

server.listen(PORT, () =&gt; {
  console.log(`Server listening at http://localhost:${PORT}`)
})</i></code></pre>
<ol start="4" type="1">
<li>Look at the Terminal where <code>nodemon</code> is running. The
details you see will be different from what you see below. But there
will be many of them.</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">[nodemon] restarting due to changes...
[nodemon] starting `node server.js`
process.env: {
  TERM_PROGRAM: 'vscode',
  rvm_bin_path: '/Users/yourname/.rvm/bin',
  NODE: '/path/to/bin/node',</code></pre>
<pre class="skip"><code class="skip"># 60 or more lines skipped</code></pre>
<pre class="language-bash wrap"><code class="language-bash wrap">  COLORTERM: 'truecolor'
}
Server listening at http://localhost:3000</code></pre>
<h2 id="adding-to-process.env">Adding to <code>process.env</code></h2>
<p>You can use a Node package called <code>dotenv</code> to add your own
data to <code>process.env</code>. Typically, you would do this as the
very first action of the first script that runs. Here’s how you can test
this for yourself.</p>
<ol type="1">
<li><p>Open a Terminal on your <code>backend/</code> directory</p></li>
<li><p>Run the command…</p>
<pre class="language-bash wrap"><code class="language-bash wrap">npm i dotenv</code></pre>
<p>… to install the <code>dotenv</code> package into the
<code>backend/node_modules</code> directory</p></li>
</ol>
<p>To add your own keys and values to <code>process.env</code>:</p>
<ol start="3" type="1">
<li>Create a file at <code>backend/.env</code></li>
<li>Enter the key-value pairs below:</li>
</ol>
<pre class="language-bash line-numbers"><code class="language-bash line-numbers">NODE_ENV=production
PORT=3333</code></pre>
<p>Edit <code>backend/server.js</code>, to…</p>
<ol start="5" type="1">
<li>Include a new line at the beginning</li>
<li>Read the value of <code>PORT</code> from the <code>.env</code>
file</li>
</ol>
<p>… as shown below.</p>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * server.js
 */

</i><b>require('dotenv').config()</b><i>
console.log("process.env:", JSON.stringify(process.env, null, 2))

const express = require('express')
const router = require('./router')
const PORT = </i><b>process.env.PORT || 3000</b><i>

const server = express()
server.use(require('cors')())

server.use(express.static('public'));
server.use('/', router)

server.listen(PORT, () =&gt; {
  console.log(`Server listening at http://localhost:${PORT}`)
})</i></code></pre>
<ol start="7" type="1">
<li>In the Terminal where <code>nodemon</code> is running, stop
<code>nodemon</code> by pressing <code>^C</code> (Ctl-C). You need to do
this because <code>nodemon</code> does not watch for changes in
<code>.env</code>, so you must restart it manually.</li>
<li>Restart <code>nodemon</code> by running <code>npm start</code>. (You
can press the Up Arrow on your keyboard to avoid typing this
again.)</li>
<li>Look in the Terminal.</li>
</ol>
<p>This time, the keys and values that you entered should appear at the
end of the long list of items:</p>
<pre class="language-bash wrap"><code class="language-bash wrap"><i>[nodemon] starting `node server.js`
process.env: {
  TERM_PROGRAM: 'vscode',
  rvm_bin_path: '/Users/yourname/.rvm/bin',
  NODE: '/path/to/bin/node',
  
  ... and many many more lines

  COLORTERM: 'truecolor',
  </i><b>NODE_ENV: 'production',
  PORT: '3333'</b><i>
}
Server listening at http://localhost:3333</i></code></pre>
<p>Notice that your server is now running on the custom
<code>PORT</code> number that you defined in your <code>.env</code>
file.</p>
<p>Notice also that <em>all the values</em> in <code>process.env</code>
are strings. The value for <code>PORT</code> is not the <em>number</em>
<code>3333</code> but the <em>string</em> <code>"3333"</code>. Remember
this. You’ll need this insight later.</p>
<h2 id="dotenv.config"><code>dotenv.config()</code></h2>
<p>The line <code>require('dotenv').config()</code> is all that you need
to load the <code>dotenv</code> package and get it to run the code that
adds data from <code>.env</code> to <code>process.env</code>. Your
custom variables are now available to any script that is run by this
process.</p>
<details class="env" open>
<summary>
<code>require</code> or <code>import</code>?
</summary>
<p>If you prefer to work with JavaScript modules, which use
<code>import</code> instead of <code>require</code>, the command you
should use is:</p>
<pre class="language-js wrap"><code class="language-js wrap">import 'dotenv/config'</code></pre>
<p>See the <a
href="https://www.npmjs.com/package/dotenv#%EF%B8%8F-usage">official
documentation</a> for details.</p>
</details>
<p>Now that you’ve seen how it works you can:</p>
<ol start="10" type="1">
<li>Delete the following temporary line from <code>server.js</code>.
Your Terminal window will thank you for it.</li>
</ol>
<pre class="language-javascript line-numbers" data-start="6"><code class="language-javascript line-numbers">console.log("process.env:", JSON.stringify(process.env, null, 2))</code></pre>
</section>
<!-- Checking for dev mode -->
<section id="checking-for-dev-mode" aria-labelledby="checking-for-dev-mode" data-item="Check for Dev Mode">
<h2>
<a href="#checking-for-dev-mode">Checking for <code>development</code>
Mode</a>
</h2>
<p>You want your server to be secure in production mode. You have
explicitly sent <code>NODE_ENV=production</code> in the
<code>.env</code> file. If this value is <em>not</em> set, then your
server can consider that it is running in <em>development</em> mode, and
that it can relax its security.</p>
<p>You can create a <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions">regular
expression</a> to match any of the common values for
<code>NODE_ENV</code> that developers use to indicate that the project
is in the production environment.</p>
<p>Here’s the expression…</p>
<pre class="language-js line-numbers"><code class="language-js line-numbers">const PROD_REGEX = /^(prod|production|staging|release|deploy)$/i</code></pre>
<p>… and you can test it <a
href="https://regex101.com/r/d4ilhU/1">here</a>.</p>
<h2 id="testing-if-your-server-is-running-in-production-mode">Testing if
your server is running in production mode</h2>
<p>Here’s how you can test it directly in your <code>server.js</code>
file. (Note that the <code>console.log(...)</code> lines 11-16 are only
temporary.)</p>
<ol type="1">
<li>Edit the beginning of <code>server.js</code> so that it matches the
code shown below.</li>
</ol>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * server.js
 */

require('dotenv').config()
            
</i><b>const PROD_REGEX = /^(production|prod|staging|release|deploy)$/i
const is_dev = !PROD_REGEX.test(process.env.NODE_ENV)
process.env.IS_DEV = is_dev

console.log(`is_dev:
  ${is_dev} (${typeof is_dev})`)
console.log(
  `process.env.IS_DEV:,
  ${process.env.IS_DEV} (${typeof process.env.IS_DEV})`
)</b><i>

const express = require('express')</i></code></pre>
<pre class="skip"><code class="skip">// Several lines skipped</code></pre>
<details class="note" open>
<summary>
Why create process.env.IS_DEV?
</summary>
<p>Other scripts that you haven’t written yet will also want to know the
value of <code>is_dev</code>. Adding a new key-value pair to
<code>process.env</code> means that these future scripts can read the
value directly from <code>process.env</code>, without having to know
about <code>PROD_REGEX</code></p>
<p>REMINDER: All values in <code>process.env</code> are converted to
strings. This means that the value of <code>process.env.IS_DEV</code> is
not <code>true</code> (as you might expect) but <code>"true"</code>.
Because <code>"true"</code> is a <em>truthy</em> value, you might not
notice this subtle detail.</p>
<p>However, in <code>.env</code> you just set
<code>NODE_ENV=production</code>. As a result,
<code>process.env.IS_DEV</code> will take the value
<code>"false"</code>. And <code>"false"</code> is a string which is
<em>not empty</em>, so JavaScript gives <code>"false"</code> a
<em>truthy</em> value, too.</p>
<p>When other scripts in backend app check later if they are running in
development mode, then you will have to make an explicit test, to
convert the string to a Boolean:</p>
<pre class="language-js"><code class="language-js">const is_dev = process.env.IS_DEV === true</code></pre>
</details>
<p>After you make this change to <code>server.js</code>, your server
should restart.</p>
<ol start="2" type="1">
<li>Look in the Terminal window where you ran <code>npm start</code>.
You should see this:</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">[nodemon] restarting due to changes...
[nodemon] starting `node server.js`
is_dev:
  false (boolean)
process.env.IS_DEV:,
  false (string)
Server listening at http://localhost:3333</code></pre>
<h2 id="what-if-node_envdev">What if NODE_ENV=dev?</h2>
<p>To check that your server will also be aware when it is in
development mode:</p>
<ol type="1">
<li>Open <code>backend/.env</code></li>
<li>Set the key-value pairs as shown below</li>
</ol>
<pre class="language-bash line-numbers"><code class="language-bash line-numbers">NODE_ENV=dev
PORT=3000</code></pre>
<ol start="3" type="1">
<li>Stop your Express server (^C)</li>
<li>Restart it</li>
<li>Look at the last few lines in the Terminal window:</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">is_dev:
  true (boolean)
process.env.IS_DEV:,
  true (string)
Server listening at http://localhost:3333</code></pre>
</section>
<!-- No CORS in production -->
<section id="cors-only-in-dev" aria-labelledby="cors-only-in-dev" data-item="CORS only in dev">
<h2>
<a href="#cors-only-in-dev">Run CORS only in development mode</a>
</h2>
<p>You are now ready to ensure that your backend Express server will
only allow clients to use the response to requests if the request comes
from the Express site itself.</p>
<ol type="1">
<li>Open <code>server.js</code></li>
<li>Delete the temporary <code>console.log(...)</code> lines (11 -
16)</li>
<li>Add five new lines highlighted, so that your code matches the
listing below.</li>
</ol>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * server.js
 */

require('dotenv').config()
            
const PROD_REGEX = /^(production|prod|staging|release|deploy)$/i
const is_dev = !PROD_REGEX.test(process.env.NODE_ENV)
process.env.IS_DEV = is_dev

const express = require('express')
const router = require('./router')
const PORT = process.env.PORT || 3000

const server = express()
</i><b>if (is_dev) {
  // Accept all requests... but only in dev mode
  console.log("🤚USING CORS FOR DEVELOPMENT")
  server.use(require('cors')())
}</b><i>

server.use(express.static('public'));
server.use('/', router)

server.listen(PORT, () =&gt; {
  console.log(`Server listening at http://localhost:${PORT}`)
})</i></code></pre>
<p><code>nodemon</code> should now restart your server for you, and you
should see this printed in the Terminal:</p>
<pre class="language-bash"><code class="language-bash">[nodemon] restarting due to changes...
[nodemon] starting `node server.js`
🤚USING CORS FOR DEVELOPMENT
Server listening at http://localhost:3333</code></pre>
<h2 id="switch-back-to-production-mode">Switch back to production
mode</h2>
<ol type="1">
<li>Edit your <code>backend/.env</code> file as shown below, so that the
frontend will find the backend where it expects to find it on port
3000.</li>
</ol>
<pre class="env line-numbers"><code class="env line-numbers">NODE_ENV=production
PORT=3000</code></pre>
<ol start="2" type="1">
<li>In the Terminal where <code>nodemon</code> is running, stop
<code>nodemon</code> by pressing <code>^C</code> (Ctl-C).</li>
<li>Restart <code>nodemon</code> manually by running
<code>npm start</code></li>
<li>Look at the last couple of lines in the Terminal:</li>
</ol>
<pre class="language-bash"><code class="language-bash">[nodemon] starting `node server.js`
Server listening at http://localhost:3000</code></pre>
<p>This time, the line <code>🤚USING CORS FOR DEVELOPMENT</code> is not
shown. In production mode, your server is not using the
<code>cors</code> module.</p>
<h2 id="and-back-to-development-mode">And… back to development mode</h2>
<p>For the next part of this tutorial, you should be working in
development mode, knowing that your backend server will be more secure
when it is running in production mode later.</p>
<ol type="1">
<li>Edit your <code>backend/.env</code> file as shown below, so that the
frontend will find the backend where it expects to find it on port
3000.</li>
</ol>
<pre class="language-bash line-numbers"><code class="language-bash line-numbers">NODE_ENV=dev
PORT=3000</code></pre>
<ol start="2" type="1">
<li>In the Terminal where <code>nodemon</code> is running, stop
<code>nodemon</code> by pressing <code>^C</code> (Ctl-C).</li>
<li>Restart <code>nodemon</code> manually by running
<code>npm start</code></li>
</ol>
<p>You won’t need to change this for a while.</p>
</section>
<!-- So what is the problem? -->
<section id="so-what-is-the-problem" aria-labelledby="so-what-is-the-problem" data-item="What&#39;s the Problem?">
<h2>
<a href="#so-what-is-the-problem">So What Is the Problem?</a>
</h2>
<p>Back in section <a href="#using-nodemon">29. Using
<code>nodemon</code></a> I suggested there was a problem with the fact
that <a href="http://localhost:3000/ping">http://localhost:3000/ping</a>
worked. What is that problem?</p>
<p>In your browser, visit <a
href="http://localhost:5173/ping">http://localhost:5173/ping</a>. What
do you see? You see the same page that you would see if you visit <a
href="http://localhost:5173/ping">http://localhost:5173</a> without the
<code>/ping</code> path.</p>
<figure>
<img src="images/5173_ping.webp"
alt="The development frontend behaves the same regardless of the path" />
<figcaption aria-hidden="true">The development frontend behaves the same
regardless of the path</figcaption>
</figure>
<p>That’s good. That means that Vite’s development server is not leaking
any data to anyone who visits an API endpoint directly from their
browser address bar (or any other API client, such as <a
href="https://www.postman.com/">Postman</a>).</p>
<p>But what if you visit the <code>/ping</code>API endpoint using your
Express server, at <a
href="http://localhost:3000/ping">http://localhost:3000/ping</a> ?</p>
<figure>
<img src="images/3000_ping.webp"
alt="A direct request from the browser address bar to a backend endpoint" />
<figcaption aria-hidden="true">A direct request from the browser address
bar to a backend endpoint</figcaption>
</figure>
<p>Ouch! There it is! That’s bad. You do not want your backend API to
send any data to someone who just happens to make a direct request for
it. You want your server to detect whether the request came through an
official page, officially served by the server itself.</p>
<p>Already, back in section <a href="#using-nodemon">29. Using
<code>nodemon</code></a>, you could see that data that you might want to
hide is available for anyone to see. At that point, though, you were
probably happy that the request to <a
href="http://localhost:3000/ping">http://localhost:3000/ping</a> was
working and your project was advancing.</p>
<details class="pivot" open>
<summary>
Keeping the server’s secrets
</summary>
<p>In this particular case, the only secret that the client didn’t
already know is the time zone, but the same thing would happen with GET
requests for data from your database, and you might not realize what a
treasure this could be for your competitors.</p>
<p>The next step will be to fix this, by requiring authentication for
any API requests to the server.</p>
</details>
</section>
<!-- Just One More Thing -->
<section id="just-one-more-thing" aria-labelledby="just-one-more-thing" data-item="Just One More Thing">
<h2>
<a href="#just-one-more-thing">Just One More Thing…</a>
</h2>
<p>Oh… but first, now there’s another issue. You can see it if you:</p>
<ol type="1">
<li>Run <code>npm run publish</code> in the parent directory</li>
<li>Reload <a href="http://localhost:3000">http://localhost:3000</a> in
your browser</li>
<li>Look in the Development Console</li>
</ol>
<figure>
<img src="images/local_origin.webp"
alt="The Express server knows the ORIGIN that was set in the frontend" />
<figcaption aria-hidden="true">The Express server knows the
<code>ORIGIN</code> that was set in the frontend</figcaption>
</figure>
<p>Do you see it? The value that the frontend is using for
<code>ORIGIN</code> has been logged to the Console. Sure, it’s the right
value. But… where was it set? Why was it set? Won’t it ever change?</p>
<p>In the files that Vite created during the <code>build</code> process,
the value for <code>import.meta.env.VITE_ORIGIN</code> has been
hard-coded in. If you decide to run your production Express server on a
different port than the one you used during development (port
<code>3333</code> for example), then the frontend that your server
delivers will attempt to connect to the <em>wrong</em> backend. And your
site will break.</p>
<p>This will need to be fixed, too, but you can only do one thing at a
time. So write this on a Post-It note and stick it somewhere so you
don’t forget to deal with it later.</p>
</section>
<!-- Special treatment for `index.html` -->
<section id="special-treatment-for-index-html" aria-labelledby="special-treatment-for-index-html" data-item="Treating index.html">
<h2>
<a href="#special-treatment-for-index-html">Special Treatment For
<code>index.html</code></a>
</h2>
<p>You want your backend Express server to detect when a request is made
to one of its API routes, and to honour the request only if it came
throug official channels.</p>
<p>If your server were a hotel, it would want to let clients into their
rooms only if they first visited reception, and received a room key. You
wouldn’t want people to walk in uninvited, go directly to a room, and
move in.</p>
<p>In other words, you need to make a client’s first interaction with
your server to be a visit to some kind of reception desk.</p>
<p>In server-speak, when someone asks the server for the
<code>index.html</code> , the server needs to:</p>
<ul>
<li>Create a token (a key for the room)</li>
<li>Wrap the token in a cookie (attach it to an official hotel key
ring)</li>
<li>Respond to the requests with both the content of
<code>index.html</code> and the cookie (give the key and the key ring to
the client who requested access).</li>
</ul>
<p>The server uses <code>express.static('public')</code> to serve the
<code>index.html</code> page. If the server finds the requested
<code>path</code> inside the <code>public/</code> folder, it will send
the page and stop there. It won’t do any more processing after it has
sent a response.</p>
<p>This means that you will have to get the server to create the cookie
before it looks for anything in the <code>public/</code> folder.</p>
<p>OK. So “kitchen” might be a better metaphor than “reception desk”,
since we’re talking about cookies.</p>
<h2 id="preparing-the-kitchen">Preparing the kitchen</h2>
<ol type="1">
<li>Create a new file at <code>backend/serveCookie.js</code>, but leave
it empty for now.</li>
<li>Add a couple of new lines to the <code>server.js</code> file. Be
warned: this will break the server, because it will look for data from
<code>serveCookie.js</code>, and I just now told you to leave it
empty.</li>
</ol>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * server.js
 */

require('dotenv').config()
            
const PROD_REGEX = /^(production|prod|staging|release|deploy)$/i
const is_dev = !PROD_REGEX.test(process.env.NODE_ENV)
process.env.IS_DEV = is_dev

const express = require('express')
</i><b>const serveCookie = require('./serveCookie')</b><i>
const router = require('./router')
const PORT = process.env.PORT || 3000

const server = express()
if (is_dev) {
  // Accept all requests... but only in dev mode
  console.log("🤚USING CORS FOR DEVELOPMENT")
  server.use(require('cors')())
}

</i><b>server.use(serveCookie)</b><i>
server.use(express.static('public'))
server.use('/', router)

server.listen(PORT, () =&gt; {
  console.log(`Server listening at http://localhost:${PORT}`)
})</i></code></pre>
<p>If <code>nodemon</code> is still running, then you’ll see an error in
the Terminal that includes the some detail like this:</p>
<pre class="skip"><code class="skip"># lines skipped here</code></pre>
<pre class="language-bash wrap"><code class="language-bash wrap">[nodemon] starting `node server.js`
/path/to/MyProject/backend/node_modules/express/lib/application.js:217
    throw new TypeError('app.use() requires a middleware function')
    ^
    
TypeError: app.use() requires a middleware function
    at Function.use (/path/to/MyProject/backend/node_modules/express/lib/application.js:217:11)
    at Object.&lt;anonymous&gt; (<b>/path/to/MyProject/backend/server.js:23:8</b>)</code></pre>
<pre class="skip"><code class="skip"># and more linse skipped here</code></pre>
<p>Can you see where it tells you the exact line in your
<code>server.js</code> script where the error occurred, and that the
reason was because Express <em>requires a middleware function</em>?</p>
<details class="note" open>
<summary>
Different line number?
</summary>
<p>The line number that is given for <code>backend/server.js:...)</code>
might be different for you, because your script might have different
lines.</p>
</details>
</section>
<!-- serveCookie -->
<section id="servecookie" aria-labelledby="servecookie" data-item="serveCookie">
<h2>
<a href="#servecookie">serveCookie: a Middleware Function</a>
</h2>
<p>You’ve already used third-party middleware functions. Both
<code>cors()</code> and <code>express.static('public')</code> return
middleware functions. Now it’s time to make your own and ensure that it
gets assigned to <code>serveCookie</code>.</p>
<p>You can start with a placeholder middleware function.</p>
<ol type="1">
<li>Open the file that you created at
<code>backend/serveCookie.js</code></li>
<li>Type into it the code that you see below.</li>
</ol>
<pre class="language-js line-numbers"><code class="language-js line-numbers">/**
 * backend/serveCookie.js
 */

const serveCookie = (req, res, next) =&gt; {
  const { path } = req
  console.log("path:", path)
  next()
}

module.exports = serveCookie</code></pre>
<p>In your Terminal window, <code>nodemon</code> should now happily
restart your server:</p>
<pre class="language-bash"><code class="language-bash">[nodemon] restarting due to changes...
[nodemon] starting `node server.js`
🤚USING CORS FOR DEVELOPMENT
Server listening at http://localhost:3000</code></pre>
<ol start="3" type="1">
<li>In your browser, visit <a
href="http://localhost:3000/">http://localhost:3000/</a></li>
</ol>
<p>In your Terminal window where you ran <code>npm start</code> you
should see output like the following :</p>
<pre class="language-bash"><code class="language-bash">path: /
path: /assets/index-CREjuYt1.js
path: /assets/index-B1jir2rU.css
path: /vite.svg</code></pre>
<p>The random numbers and letters used for the names of the files in the
<code>/assets/</code> directory will be different, and you might or
might not see an entry like <code>path: /vite.svg</code>.</p>
<h2 id="what-is-servecookie-doing">What is <code>serveCookie</code>
doing?</h2>
<p>In <code>server.js</code>, the line
<code>server.use(serveCookie)</code> comes before any code that sends a
response back to the browser. When your server receives a request, it
works through the code, line-by-line until something goes wrong (as it
did earlier), or until it Express sends a response.</p>
<p>So, <code>serverCookie()</code> will be called for every request that
the server receives. You’ve already seen how the <code>ping</code>
function for the <code>/ping</code> route can read the value of
<code>path</code> for the <code>req</code> argument, and send a response
using the <code>res</code> argument. Here there is a third argument:
<code>next</code>.</p>
<p>The <code>serveCookie</code> function reads the <code>path</code> and
simply logs it to the console. The <code>path</code> that was requested
was <code>/</code>, but three or four paths are logged. This implies
that there must have been several different requests.</p>
<p>When the browser receives the <code>index.html</code> page is loaded,
it reads its contents and requests the JavaScript file, the CSS file and
the image that will be displayed in the browser tab for this page.</p>
<p>But <code>serverCookie()</code> doesn’t actually send any data back
to the browser. After it had logged the request <code>path</code>, it
simply called <code>next()</code>.</p>
<h3 id="next"><code>next()</code></h3>
<p>If no data were sent back to the browser, the browser would just sit
and wait. It would just freeze. Express gives middleware the chance to
do one of two things:</p>
<ul>
<li><p>Trigger a response method with the <code>res</code> object</p>
<p>OR</p></li>
<li><p>Let the <em>next</em> middleware function or routing method take
over</p></li>
</ul>
<p>The queue of <code>next</code> functions can be set up in several
different ways. If no <code>next</code> function is specifically given,
Express will continue with the next <code>use()</code> statement. In
this case, the next <code>use()</code> statement is on line 24 of
<code>server.js</code>:</p>
<pre class="language-js line-numbers" data-start="23"><code class="language-js line-numbers">server.use(serveCookie)
server.use(express.static('public'))</code></pre>
<p>This looks for the <code>/index.html</code> file in the
<code>backend/public/</code> folder, and sends it to the browser. And
the browser asks for the JavaScript file (from the the
<code>backend/public/</code> folder), and the CSS file (from the same
place) and perhaps the SVG file (also).</p>
<h2 id="only-index.html-gets-a-cookie">Only <code>index.html</code> gets
a cookie</h2>
<p>As you can see, every request that the server receives is channeled
through the <code>serveCookie()</code> function. But it only makes sense
to send a cookie with a request for <code>/index.html</code> itself.
Because a request for <code>/</code> implies a request for
<code>/index.html</code>, both cases must be treated.</p>
<p>Here’s how you can check the <code>path</code> so other requests
don’t get any special treatment.</p>
<ol type="1">
<li>Add an <code>if</code> statement to your <code>serveCookie.js</code>
file, as shown below:</li>
</ol>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * backend/serveCookie.js
 */

module.exports = (req, res, next) =&gt; {
  const { path } = req
  console.log("path:", path)
  </i><b>if ( path === "/" || path === "index.html" ) {
    console.log("Cookies!")
  }</b><i>
  next()
}</i></code></pre>
<ol start="2" type="1">
<li>Refresh your browser</li>
<li>Look at the output in the Terminal</li>
</ol>
<pre class="language-bash"><code class="language-bash">
[nodemon] restarting due to changes...
[nodemon] starting `node server.js`
Server listening at http://localhost:3000
path: /
Cookies!
path: /assets/index-B1jir2rU.css
path: /assets/index-CREjuYt1.js
path: /vite.svg</code></pre>
<p>Only the request for <code>/</code> resulted in
<code>"Cookies!"</code> being logged.</p>
<p>The next step is to prepare the secret ingredients for the token that
will be the filling for the cookie.</p>
</section>
<!-- Authentication with tokens -->
<section id="authentication-with-tokens" aria-labelledby="authentication-with-tokens" data-item="Authentication">
<h2>
<a href="#authentication-with-tokens">Authentication With Tokens</a>
</h2>
<p>You want to allow any API requests that are sent to the backend by
your frontend, and to block all API requests that come from any other
sources. To do this, you can get your frontend to send an
<em>authentication token</em> with all of its requests. Your backend can
then check if a given API request comes with a valid token, and block
any requests that do not.</p>
<p>To continue the hotel metaphor, the authentication token is an
official key for a hotel room door.</p>
<h2 id="requests-paths-and-headers">Requests, paths and headers</h2>
<p>When a client makes a request to your server, the request URL has two
main parts:</p>
<ul>
<li>The <em>origin</em> of your backend server. This is comprised of
<ul>
<li>the protocol</li>
<li>the sub-domain names (if any)</li>
<li>the domain name or IP address</li>
<li>the port number</li>
</ul>
In the current case, the origin that you are using for your backend
server is <code>http://localhost:3000</code>.</li>
<li>The <em>path</em>. This consists of everything after the origin (and
before any <code>?</code> or <code>#</code> character, if you want to be
exact). If the path is empty, it is implicitly converted to a
<code>/</code> slash character. If it is a <code>/</code> character, it
will be treated as <code>/index.html</code>.</li>
</ul>
<p>If you type <a
href="%60http://localhost:3000%60">http://localhost:3000</a> into your
browser’s address bar, your server will respond with the contents of the
page at <code>backend/public/index.html</code>. If there is JavaScript
attached to this<code>index.html</code> page, and this script makes a
request to <code>"/some-path"</code>, your browser will:</p>
<ul>
<li>Make a request for <a
href="http://localhost:3000/some-path">http://localhost:3000/some-path</a></li>
<li>Send a <code>Referer</code> header which gives the value of
http://localhost:3000/, because that is where the sender page was loaded
from.</li>
</ul>
<p>In the original request for <a
href="%60http://localhost:3000%60">http://localhost:3000</a>, the
browser did not send a <code>Referer</code> header giving an origin,
because the request came from the browser itself, not from JavaScript
within a web page. The request was not being referred from anywhere.</p>
<h2 id="requests-that-dont-come-from-a-browser">Requests that don’t come
from a browser</h2>
<p>You don’t need to use a browser to make a request from a server. You
can use an API platform like <a
href="https://www.postman.com/">Postman</a> or even a simple <a
href="https://curl.se/docs/tutorial.html"><code>curl</code></a> command
directly from your Terminal. Try it in a new Terminal window:</p>
<pre class="language-bash wrap"><code class="language-bash wrap">$ <b>curl http://localhost:3000/ping</b>

&lt;pre&gt;Connection from:
referer undefined
origin  undefined
ip      ::1
for     http://localhost:3000/ping
at      Tue Nov 19 2024 13:01:21 GMT+0100 (Central European Standard Time)&lt;/pre&gt;</code></pre>
<details class="tip" open>
<summary>
Need to install <code>curl</code>?
</summary>
<p>If you get a message like <code>command not found: curl</code>, you
can <a
href="https://help.ubidots.com/en/articles/2165289-learn-how-to-install-run-curl-on-windows-macosx-linux">install
the <code>curl</code> program from here</a></p>
</details>
<p>With Postman or <code>curl</code>, you <em>can</em> send any
<code>referer</code> or <code>origin</code> header that you want:</p>
<pre class="language-bash wrap"><code class="language-bash wrap">$ <b>curl \
-H "Referer: https://not-evil.example.com/" \
-H "Origin: https://pure-good.example.com" \
http://localhost:3000/ping</b>

&lt;pre&gt;Connection from:
referer https://not-evil.example.com/
origin  https://pure-good.example.com
ip      ::1
for     http://localhost:3000/ping
at      Tue Nov 19 2024 13:04:57 GMT+0100 (Central European Standard Time)&lt;/pre&gt;   </code></pre>
<p>This means that a malevolent actor who has chosen not to use a secure
browser can pretend to be connecting from somewhere else.</p>
<h2 id="why-use-authentication-tokens">Why use authentication
tokens?</h2>
<p>In other words, your backend must not trust the incoming value for
<code>origin</code>. What your backend <em>can</em> do is:</p>
<ul>
<li>Treat any incoming request for <code>/</code> as trustworthy</li>
<li>Reply to the <code>/</code> request with
<ul>
<li>The <code>index.html</code> page</li>
<li>A signed, encrypted token…</li>
<li>… that gives a key to the server</li>
<li>… with a short expiry time…</li>
<li>… wrapped in a cookie…</li>
<li>… with the <code>SameSite</code> attribute set to
<code>Strict</code>…</li>
<li>… and the <code>HttpOnly</code> attribute set to
<code>true</code>.</li>
</ul></li>
<li>For any incoming request that has a path other than <code>/</code>
<ul>
<li>Check that there is an incoming cookie with the expected signature
and values</li>
<li>If so: treat the request and respond accordingly</li>
<li>If not: respond with a 403 Unauthorized message, if not</li>
</ul></li>
</ul>
<details class="note" open>
<summary>
Cookie attributes
</summary>
<p>I’ll explain what all the token and cookie attributes mean as you are
writing the code for them.</p>
</details>
<p>In this way, even if the request does come from a malicious actor
using an unorthodox method for making the request, they will only get
the same data that they would have received if they had used a reputable
browser. It’s a bit like giving forgers only what they pay for with real
money, even if they are wearing a disguise.</p>
<details class="warn" open>
<summary>
Loopholes
</summary>
<p>Having said that, there <em>are</em> ways a hacker could inject code
into your web pages, if you do not take the right precautions. Your
server would respond to such injected code as if it were legitimate.
However, the service that you are creating in this tutorial does not
open up any of these loopholes, so there’s no need to discuss here how
to protect your server from them.</p>
</details>
</section>
<!-- Secret ingredients -->
<section id="secret-ingredients" aria-labelledby="secret-ingredients" data-item="Secret Ingredients">
<h2>
<a href="#secret-ingredients">Secret Ingredients</a>
</h2>
<p>You don’t want anyone else to be able to create a token that gives
access to your API. If you create a repository on GitHub for your
project, other people can share your code, and build something similar
for themselves. But you don’t want to give anyone the key that will give
access to the API on <em>your</em> server.</p>
<p>The standard place to hide your secrets is in a file named
<code>.env</code> . You might use different secrets when you are
developing than when you deploy your server for production. Your
development environment and production environment <code>.env</code>
files may contain different values for the same keys.</p>
<p>You’ve already created a <code>.env</code> file for your backend, so
that you can tell your server when it is running in production mode, and
which port number to use.</p>
<p>Now you can add to it the secret ingredients that will use to make
the cookie filling.</p>
<ol type="1">
<li>In the file <code>backend/.env</code> add two new lines:</li>
</ol>
<pre class="language-bash line-numbers"><code class="language-bash line-numbers"><i>NODE_ENV=dev
PORT=3000</i>
<b>JWT_SECRET=go hang a salami
COOKIE_SECRET=I'm a lasagna hog</b></code></pre>
<p>You should use your own phrases, specifically ones that you think
no-one else will guess. There doesn’t need to be any connection between
them.</p>
</section>
<!-- Making a JWT token -->
<section id="making-a-jwt-token" aria-labelledby="making-a-jwt-token" data-item="Making A JWT Token">
<h2>
<a href="#making-a-jwt-token">Making A JWT Token</a>
</h2>
<p>Just to remind you what we are working on:</p>
<p>When someone asks the server for the <code>index.html</code> , the
server needs to:</p>
<ul>
<li>Create a token</li>
<li>Wrap the token in a cookie</li>
<li>Respond to the requests with the <code>index.html</code> and the
cookie.</li>
</ul>
<p>But what exactly should the token contain?</p>
<p>When you register at a hotel, it’s likely that the hotel will give
you a key with a big clunky fob (so you don’t forget to give it back
later). On the fob is written:</p>
<ul>
<li>The name-and-address of the hotel</li>
<li>Your room number</li>
</ul>
<p>If you have that key, you can open that room in that hotel. It will
probably also open the front door of the hotel, if that is ever
locked.</p>
<p>The token that you are going to create will contain:</p>
<ul>
<li>The <em>origin</em> of the server</li>
</ul>
<p>That is: the protocol, the host name and the port number where the
server is running. In other words, the token will say: “You have the
right to enter here”.</p>
<h2 id="jsonwebtoken">jsonwebtoken</h2>
<p>A key is precision-made. The tool for making such a key for your
server is a Node package called <code>jsonwebtoken</code>. You can find
out all about JSON Web Tokens on <a
href="https://jwt.io/">JWT.io</a>.</p>
<details class="note" open>
<summary>
JWT tokens
</summary>
<p>The written abbreviation is JWT, and the conventional spoken name for
them is “joot token”, as if the “w” were a long “uu” sound, and the “t”
that stands for “token” is also explicitly spoken aloud. Like the “N” in
PIN number.</p>
</details>
<p>A JWT token is treated in two ways:</p>
<ul>
<li>Its contents are encoded using the <a
href="https://en.wikipedia.org/wiki/Base64">Base64Url</a> scheme, to
make it easy to transfer it over the Internet</li>
<li>Its encoded contents are hashed, using your secret key, to create a
signature, which is then appended to the encoded contents.</li>
</ul>
<p>This means that anyone can use Base64Url decoding to <em>read</em>
the contents, but if anyone tries to <em>change</em> the contents, the
contents will no longer match the signature.</p>
<p>When your server receives such a token, it can re-hash the contents
part of the message using its secret key, and check that the result
matches the signature. You can find <a
href="https://jwt.io/introduction">a full explanation of this</a> on the
JWT.io site.</p>
<p>The <code>backend/jwToken.js</code> script below takes care of all
this for you. If you want to understand the details, you’ll find that
the concepts used to write this script are described in the <a
href="https://www.npmjs.com/package/jsonwebtoken">official documentation
for jsonwebtoken</a>.</p>
<p>The important points to note are that:</p>
<ul>
<li>The <code>payload</code> that you will provide as input will be the
origin of your server. For now, this is
<code>"http://localhost:3000"</code>.</li>
<li>The output will be a not-so-short, unreadable string, such as</li>
</ul>
<pre class="language-bash wrap"><code class="language-bash wrap">"eyJhbGciOiJIUzI1NiJ9.aHR0cDovL2xvY2FsaG9zdDozMDAwLw.uCiWAKmFSuGayhuHg2XxTpiF858Dpoqlf8CFMZwR6dw"</code></pre>
<ol type="1">
<li><p>Open a Terminal window in the <code>backend/</code>
folder</p></li>
<li><p>Run the command…</p>
<pre class="language-bash wrap"><code class="language-bash wrap">npm i jsonwebtoken</code></pre>
<p>… to install the package in the <code>node_modules</code>
directory.</p></li>
<li><p>Create a file at <code>backend/jwToken.js</code> and paste the
following into it.</p></li>
</ol>
<pre class="language-js line-numbers"><code class="language-js line-numbers">/**
 * backend/jwToken.js
 */

const jwt = require("jsonwebtoken")
const JWT_SECRET = process.env.JWT_SECRET || "secret needed"

const DEFAULTS = {
  algorithm: 'HS256',
  allowInsecureKeySizes: true
}

const getToken = ( payload, options = {} ) =&gt; {
  if (typeof options !== "object") {
    // Ignore options if it's not an object
    options = {}
  }

  // Overwrite DEFAULTS with explicit options with the same key
  options = { ...DEFAULTS, ...options }

  const token = jwt.sign(
    payload,
    JWT_SECRET,
    options
  )

  return token
}

module.exports = {
  getToken
}</code></pre>
<p>Now, to actually create such a token and use it as the filling for a
cookie…</p>
</section>
<!-- Preparing the pass token -->
<section id="preparing-the-pass-token" aria-labelledby="preparing-the-pass-token" data-item="The Pass Token">
<h2>
<a href="#preparing-the-pass-token">Preparing The Pass Token</a>
</h2>
<p>It’s time to go back to your <code>serveCookie.js</code> script, and
connect it to the <code>jwToken.js</code> script. You’ve already
isolated the case where the <code>path</code> is a request for the
<code>index.html</code> file. Now you can use some of the ideas that you
saw in the <code>ping()</code> function to generate an
<code>origin</code> string.</p>
<p>You’ll a new version of the <code>backend/serveCookie.js</code>
script below.</p>
<p><strong>Don’t do anything yet. Just take a look at the
script.</strong></p>
<p>The <code>serveCookie()</code> function:</p>
<ul>
<li>Reads in the <code>getToken</code> function that you have just
created</li>
<li>Creates a string variable called <code>origin</code>, which will
match the address where your server is running. (Almost. Can you spot
the difference? I’ll explain it later, but I’ve already give you a clue,
in section <a href="#using-cors-in-development">35. CORS at Dev Time</a>
- Figure 17.)</li>
<li>Uses your new <code>getToken()</code> function to get a signed JWT
string</li>
<li>Prints out both the value for <code>origin</code> and the JWT token
in the console</li>
</ul>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * backend/serveCookie.js
 */</i>

<b>const { getToken } = require('./jwToken')</b>

<i>module.exports = (req, res, next) =&gt; {
  const { path } = req
  
  if ( path === "/" || path === "index.html" ) {</i>
     <b>// The request is for the index.html page at the origin
     const protocol = req.protocol
     const host = req.headers.host // includes the port
     const origin = `${protocol}://${host}/`
     console.log("origin:", origin)
     
     // Create a token to record the origin that was requested...
     const pass = getToken(origin)
     console.log("pass:", pass)</b>
   }

  <i>next()
}</i></code></pre>
<details class="challenge" open>
<summary>
A challenge
</summary>
<ol type="1">
<li>Study the code inside the <code>if</code> statement in Listing 56
above</li>
<li>Check that you understand what each line does, and why</li>
<li>Open your <code>backend/serveCookie.js</code> script</li>
<li>As a challenge, hide this tutorial page and reconstruct the
<code>if</code> statement in your own script, from memory, and through
your understanding of the process. When you are finished, bring this
tutorial back into view again.</li>
<li>Compare what you’ve written with the original. There are likely to
be some small differences. Ask yourself if they are likely to cause your
code to fail, or if they are just a matter of style.</li>
<li>Check in the Terminal window where <code>nodemon</code> is running,
to see if your server has crashed. If so, check the error message(s) to
see where you need to make your fixes.</li>
<li>When your server is happily running again, open your browser and
visit <a href="http://localhost:3000/">http://localhost:3000/</a></li>
</ol>
</details>
<p>If all goes well, this is what you should see:</p>
<pre class="language-bash wrap"><code class="language-bash wrap">[nodemon] restarting due to changes...
[nodemon] starting `node server.js`
🤚USING CORS FOR DEVELOPMENT
Server listening at http://localhost:3000
origin: http://localhost:3000/
pass: eyJhbGciOiJIUzI1NiJ9.aHR0cDovL2xvY2FsaG9zdDozMDAwLw.bRo9CTSJi2PGFLsrvSeTdXulDH6sRH18MQZVs3G69hY</code></pre>
<h2 id="spot-the-difference-origin-and-referer">Spot the difference:
<code>origin</code> and <code>referer</code></h2>
<p>In Figure 17 that you saw earlier, the value for <code>origin</code>
did not have a trailing <code>/</code> slash character, but the value
for <code>referer</code> did.</p>
<figure>
<img src="images/gotPing.webp" alt="or “Figure 17 revisited”" />
<figcaption aria-hidden="true">or “Figure 17 revisited”</figcaption>
</figure>
<p>The <code>payload</code> that you have used in your JWT token above
should have a trailing <code>/</code> character, because it will be
matched against <code>req.headers.referer</code>. If the values don’t
match, the server will refuse to treat the API request. So make sure
that the value you used as the argument for <code>getToken()</code> ends
with a trailing slash.</p>
<details class="question" open>
<summary>
Whack-a-mole
</summary>
<p>Do you see a new problem that you’ll need to take care of during
development?</p>
<p>Hint: what is the value of <code>referer</code> going to be when you
are running your React frontend from the Vite development server? And
what will be the value that the server will store in the JWT token?</p>
</details>
</section>
<!-- Serving the cookie -->
<section id="serving-the-cookie" aria-labelledby="serving-the-cookie" data-item="Serving The Cookie">
<h2>
<a href="#serving-the-cookie">Serving The Cookie</a>
</h2>
<p>You’ve created the JWT token filling for the cookie, but now it’s
time to create the cookie itself.</p>
<p>Serving cookies is going to require a new Node package. There are <a
href="https://www.npmjs.com/search?q=cookie">several packages that can
handle cookies that are listed on the <code>npm</code> site</a> — over
4000 when I last visited. I’ve chosen to work with is <a
href="https://www.npmjs.com/package/cookie-session">Doug Wilson’s
cookie-session</a>, because the examples given in the documentation are
explicitly designed for Express middleware. And because Doug Wilson has
been a leading member of the Express development team.</p>
<details class="tip" open>
<summary>
A different package?
</summary>
<p>Perhaps you’ll be working with a team that has chosen a different
package from me. If that’s the case, I suggest that you work through
this tutorial using <code>cookie-session</code>, and then work with your
team to integrate their preferred Node package and understand its
specific advantages.</p>
</details>
<h2 id="what-does-cookie-session-do">What does
<code>cookie-session</code> do?</h2>
<p>The <code>cookie-session</code> middleware package manages a
<code>req.session</code> object.</p>
<p>But what is a session? A session is a series of requests that all
relate to the same goal. For example, when you visit a shopping site,
you make make one request to put an item in your shopping cart, then
another request to indicate your shipping address, and a third request
to provide payment.</p>
<p>On the first request, the server can create a session cookie and add
data to it concerning this first request. It then sends the cookie to
your browser, which sends it back again when it makes the second
request. The server can now read the data that it set as a result of the
first request, and treat the second request accordingly.</p>
<p>The <code>cookie-session</code> middleware package allows the server
to read items in the <code>req.session</code> object, as it arrives
fresh from the client, and to add or modify these items before passing
the modified cookie on to the <code>res</code> object to be sent back to
the client.</p>
<h2 id="like-a-wristband">Like a wristband</h2>
<p><code>cookie-session</code> is well suited to the current scenario.
It manages a single cookie which contains just a small amount of data.
This is all that you need in this particular case.</p>
<p>Typically, the <code>index.html</code> file will be requested only
once. There will be no cookie associated with this initial request, so
<code>cookie-session</code> will create one and add the
<code>pass</code> token to it. The cookie will be sent with any
subsequent API requests, but it will never need to be changed.</p>
<p>It will act a bit like the wristband you get when you go to an event.
You can’t take it off and give it to someone else, but so long as you
are wearing it, you can leave the event and come back in again.</p>
<h2 id="setting-up-the-server">Setting up the server</h2>
<p>To use the <code>cookie-session</code> middleware package, you’ll
need to:</p>
<ol type="1">
<li><p>Activate the Terminal window that is open on your
<code>backend/</code> directory</p></li>
<li><p>Run the command…</p>
<pre class="language-bash wrap"><code class="language-bash wrap">npm i cookie-session</code></pre>
<p>…to install the required dependencies in your
<code>node_modules</code> directory</p></li>
<li><p>Open your <code>backend/server.js</code> script</p></li>
<li><p>Add code in four places, as shown in the listing below:</p>
<ul>
<li>To load the <code>cookie-session</code> middleware module.</li>
<li>To read your <code>COOKIE_SECRET</code> from <code>.env</code>.</li>
<li>To create an object that defines the name of the cookie and its
other attributes. (You’ll see this object explained below.)</li>
<li>To <code>use()</code> the <code>cookie-session</code> middleware
with your chosen options.</li>
</ul></li>
</ol>
<details class="note" open>
<summary>
A couple of points
</summary>
<ul>
<li>Line 17 gives a default value for the <code>COOKIE_SECRET</code>,
just in case there are no settings for thitem in <code>.env</code></li>
<li>In line 33, <code>server.use(cookieSession(...))</code> is executed
just before <code>server.use(serveCookie)</code>. This means that
<code>req.session</code> will already exist, even on the first visit to
the server (in which case it will be an empty object).</li>
</ul>
</details>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * server.js
 */

require('dotenv').config()
            
const PROD_REGEX = /^(production|prod|staging|release|deploy)$/i
const is_dev = !PROD_REGEX.test(process.env.NODE_ENV)
process.env.IS_DEV = is_dev

const express = require('express')
</i><b>const cookieSession = require('cookie-session')</b><i>
const serveCookie = require('./serveCookie')
const router = require('./router')

const PORT = process.env.PORT || 3000
</i><b>const COOKIE_SECRET = process.env.COOKIE_SECRET || "string needed"

const cookieOptions = {
  name: "pass",
  keys: [ COOKIE_SECRET ],
  httpOnly: true,
  sameSite: true
}</b><i>

const server = express()
if (is_dev) {
  // Accept all requests... but only in dev mode
  console.log("🤚USING CORS FOR DEVELOPMENT")
  server.use(require('cors')())
}

</i><b>server.use(cookieSession(cookieOptions))</b><i>
server.use(serveCookie)
server.use(express.static('public'));
server.use('/', router)

server.listen(PORT, () =&gt; {
  console.log(`Server listening at http://localhost:${PORT}`)
})</i></code></pre>
<h2 id="cookieoptions"><code>cookieOptions</code></h2>
<p>The <code>cookieSession</code> middleware reads in the
<code>cookieOptions</code> object that you have created.</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr>
<th>Key</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>A sttring which sets the property name to use for the session
cookie. If you omit the <code>name</code> property, the name
<code>"session"</code> will be used by default.</td>
</tr>
<tr>
<td>keys</td>
<td>An array which contains at least one string. The first entry will be
used to sign the cookie, to ensure that it has not been altered by a
third party.</td>
</tr>
<tr>
<td><a
href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#block_access_to_your_cookies">httpOnly</a></td>
<td>A boolean. If set to true, then JavaScript on the browser will have
no access to the cookie. This is <code>true</code> by default, but it’s
important to be sure that it is set.</td>
</tr>
<tr>
<td><a
href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#controlling_third-party_cookies_with_samesite">sameSite</a></td>
<td>A boolean. If set to true, this cookie will only ever be sent to the
site where it was set. When you visit other sites, they will not even
know that this cookie exists.</td>
</tr>
</tbody>
</table>
<h2 id="adding-a-pass-to-req.session">Adding a pass to
<code>req.session</code></h2>
<p>Now that <code>req.session</code> exists, it’s easy to add the
<code>pass</code> token that you created earlier to it.</p>
<ol type="1">
<li>Edit <code>backend/serveCookie.js</code> so that it matches Listing
58 below. (Note that the <code>console.log(...)</code> statements are
gone.)</li>
</ol>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * backend/serveCookie.js
 */

const { getToken } = require('./jwToken')

module.exports = (req, res, next) =&gt; {
  const { path } = req
  
  if ( path === "/" || path === "index.html" ) {
     // The request is for the index.html page at the origin
     const protocol = req.protocol
     const host = req.headers.host
     const origin = `${protocol}://${host}/`

     // Create a token to record the origin that was requested...
     const pass = getToken(origin)
     </i><b>// ... and serve it as session cookie.
     req.session.pass = pass
 
     // All API requests need a token with this origin as referer</b><i>
   }

  next()
}</i></code></pre>
</section>
<!-- Checking for Cookies -->
<section id="checking-for-cookies" aria-labelledby="checking-for-cookies" data-item="Checking For Cookies">
<h2>
<a href="#checking-for-cookies">Checking your Browser for Cookies</a>
</h2>
<p>If you refresh your browser, nothing seems to have changed. Nothing
is logged into the Terminal window, because there are no
<code>console.log()</code> statements in <code>serveCookie.js</code> any
more.</p>
<p>But if you use the Developer Tools in your browser, you’ll see that
it now shows that you have cookies.</p>
<p>In Google Chrome, you need to select the Application tab and then
choose Cookies in the Storage section on the left. You may need to click
on the disclosure triangle and then select
<code>http://localhost:3000</code>.</p>
<figure>
<img src="images/chromeCookies.webp"
alt="Where to find cookies in Chrome &gt; Application &gt; Cookies" />
<figcaption aria-hidden="true">Where to find cookies in Chrome &gt;
Application &gt; Cookies</figcaption>
</figure>
<p>In Mozilla Firefox you need to select the Storage tab and then choose
Cookies in the section on the left. You may need to click on the
disclosure triangle and then select
<code>http://localhost:3000</code>.</p>
<figure>
<img src="images/firefoxCookies.webp"
alt="Where to find cookies in Firefox &gt; Storage &gt; Cookies" />
<figcaption aria-hidden="true">Where to find cookies in Firefox &gt;
Storage &gt; Cookies</figcaption>
</figure>
<details class="tip">
<summary>
No Storage Tab?
</summary>
<p>If you don’t immediately see a Storage tab in Firefox: 1. Click on
the three dots at the right end of the Developer Tools menu 2. Select
Settings 3. Check the Storage checkbox</p>
<figure>
<img src="images/firefoxSettings.webp" alt="Firefox Dev Settings" />
<figcaption aria-hidden="true">Firefox Dev Settings</figcaption>
</figure>
<p>Can you guess that I prefer the uncluttered arrangement of the
Firefox Development Tools?</p>
</details>
<p>Now that you have checked that your cookie is indeed getting set, you
can get ready to block any access to the <code>/ping</code> API endpoint
(or any other) if the request is not accompanied by a cookie.</p>
</section>
<!-- Checking the cookie -->
<section id="checking-the-cookie" aria-labelledby="checking-the-cookie" data-item="Checking The Cookie">
<h2>
<a href="#checking-the-cookie">Checking The Cookie</a>
</h2>
<p>When you connect to the Express server <a
href="http://localhost:3000/">http://localhost:3000/</a>, a cookie named
<code>pass</code> is set in your browser, and sent back to the server
with every subsequent request. Now you need to tell your server:</p>
<ul>
<li>To check that the <code>pass</code> cookie exists</li>
<li>To check that its payload still matches its signature</li>
<li>To check that its payload matches the <code>referer</code> value
read from the request header</li>
</ul>
<p>If all these things are true, your server can process the API
request, run any necessary server-side code, and send the appropriate
response. If any of these things are not true, the server should
immediately respond with a <code>40x</code> status and a message that
means something like “Cease and desist. You are not welcome.”</p>
<p>Here’s a function that can do this:</p>
<pre class="language-js line-numbers"><code class="language-js line-numbers">const jwt = require("jsonwebtoken")
const JWT_SECRET = process.env.JWT_SECRET || "secret needed"

const checkPass = (req, res, next) =&gt; {
  const pass = req.session?.pass
  const referer = req.headers.referer
  console.log("referer:", referer, ", req.path:", req.path)

  let status = 0
  let message = ""

  if (!pass) {
    status = 403 // Forbidden
    message = "No pass provided"
    proceed()

  } else {
    jwt.verify(pass, JWT_SECRET, treatPass)
  }

  function treatPass(error, payload) {
    console.log("payload:", payload)
    if (error) {
      status = 401 // Unauthorized
      message = "Unauthorized"

    } else if (payload !== referer) {
      status = 401 // Unauthorized
      message = "Not admitted"
    }

    proceed()
  }

  function proceed() {
    if (status) {
      return res.status(status).send({ message })
    }

    next()
  }
}</code></pre>
<h2 id="how-it-works">How it works</h2>
<p>It works in three steps.</p>
<ul>
<li>First, it assumes that all will be well, and sets the error status
to <code>0</code></li>
</ul>
<pre class="language-js line-numbers" data-start="9"><code class="language-js line-numbers">  let status = 0
  let message = ""</code></pre>
<ul>
<li>Second, it does some checking, which may either pass or fail. I’ll
look at that in detail in a moment. If it fails, <code>status</code>
will be set to a non-zero number, and <code>message</code>will be set to
a human-readable string.</li>
<li>Finally, the checking process calls the <code>proceed()</code>
function. If <code>status</code> is still <code>0</code>, the
<code>next</code> middleware or routing function will be called, and the
server will treat the request. If <code>status</code> was set to a
non-zero number, <code>proceed()</code> will immediately respond to the
request to reject it:</li>
</ul>
<pre class="language-js line-numbers" data-start="37"><code class="language-js line-numbers">return res.status(status).send({ message })</code></pre>
<h2 id="checking-the-token">Checking the token</h2>
<p>The <code>checkPass</code> function first reads the <code>pass</code>
cookie from <code>req.session</code>.</p>
<pre class="language-js line-numbers" data-start="5"><code class="language-js line-numbers">  const pass = req.session?.pass</code></pre>
<p>Because <code>cookie-session</code> was initialized in
<code>server.js</code> on start-up, you can be pretty sure that
<code>req.session</code> exists. But if, for some reason it doesn’t
exist (An interstellar cosmic ray may have zapped a single bit somewhere
in the server. Yes, <a
href="https://www.youtube.com/watch?v=AaZ_RSt0KP8.">this does
happen</a>.), then your server might respond with an error message which
gives a stack trace which gives details of how your code works. A
high-level hacker could exploit this. Worse: your server would crash.
For this reason, I have used the <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">optional
chaining operator</a> which ensures that <code>pass</code> will be set
to <code>undefined</code> if <code>req.session</code> does not
exist.</p>
<p>Next, the <code>checkPass</code> function checks if <code>pass</code>
exists at all. If not, it’s clear that the client requesting the API
resource did not do the courtesy of downloading <code>index.html</code>
before making a request to a backend endpoint.</p>
<pre class="language-js line-numbers" data-start="12"><code class="language-js line-numbers">  if (!pass) {
    status = 403 // Forbidden
    message = "No pass provided"
    proceed()

  }</code></pre>
<p>If the <code>pass</code> token does exist, then the
<code>jsonwebtoken</code> instance is asked to check if its signature
still matches the payload. It does this by:</p>
<ul>
<li>Reading the payload part of the token</li>
<li>Running the hashing algorithm that was used to create the signature
with the same secret key that was originally used.</li>
</ul>
<p>This process can take a non-negligible amount of time, so it is not
run synchronously. The <code>jwt</code> instance does this in the
background, and when it is done, it calls the <code>treatPass</code>
callback.</p>
<pre class="language-js line-numbers" data-start="18"><code class="language-js line-numbers">  jwt.verify(pass, JWT_SECRET, treatPass)

  function treatPass(error, payload) {
    if (error) {
      status = 401 // Unauthorized
      message = "Unauthorized"

    } else if (payload !== referer) {
      status = 401 // Unauthorized
      message = "Not admitted"
    }

    proceed()
  }</code></pre>
<p>If there was a discrepancy with the signature, then
<code>error</code> will be truthy, and the server won’t be able to trust
the <code>payload</code>, so no <code>payload</code> is sent as an
argument to the <code>treatPass()</code> function . Yes, perhaps there
was a payload, but it’s not authorized, so it’s ignored: error status
<code>401</code>.</p>
<h2 id="matching-the-referer">Matching the <code>referer</code></h2>
<p>If the signature part of the token matches the newly calculated
signature, then <code>error</code> will be null, and
<code>payload</code> will be the value that was initially set. However,
there is one last check to make: does the value in the token match the
<code>referer</code> header that was sent with the request?</p>
<p>This ensures that any misuse of the cookie should fail.</p>
<details class="challenge" open>
<summary>
Question 1
</summary>
<p>Where should this function go?</p>
<p>Hint: you may need to change the <code>module.exports</code>
declaration in the script to this:</p>
<pre class="language-js line-numbers"><code class="language-js line-numbers">module.exports = {
  getToken,
  checkPass
}</code></pre>
<details class="challenge" open>
<summary>
Question 2
</summary>
<p>Where should it be called from?</p>
<p>Hint: earlier you created a <code>router</code> to handle all
requests that could not be fulfilled by a file in the
<code>backend/public/</code> directory. The <code>pass</code> cookie
should be checked before any call to any API route, such as
<code>/ping</code>.</p>
</details>
<details class="solution" open>
<summary>
Solution
</summary>
<ol type="1">
<li>Edit your <code>backend/jwToken.js</code> file to look like
this:</li>
</ol>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * backend/jwToken.js
 */

const jwt = require("jsonwebtoken")
const JWT_SECRET = process.env.JWT_SECRET || "secret needed"

const DEFAULTS = {
  algorithm: 'HS256',
  allowInsecureKeySizes: true
}

const getToken = ( payload, options = {} ) =&gt; {
  if (typeof options !== "object") {
    // Ignore options if it's not an object
    options = {}
  }

  // Overwrite DEFAULTS with explicit options with same key
  options = { ...DEFAULTS, ...options }

  const token = jwt.sign(
    payload,
    JWT_SECRET,
    options
  )

  return token
}


</i><b>const checkPass = (req, res, next) =&gt; {
  const pass = req.session?.pass
  const referer = req.headers.referer
  console.log("referer:", referer, ", req.path:", req.path)

  let status = 0
  let message = ""

  if (!pass) {
    status = 403 // Forbidden
    message = "No pass provided"
    proceed()

  } else {
    jwt.verify(pass, JWT_SECRET, treatPass)
  }

  function treatPass(error, payload) {
    console.log("payload:", payload)
    if (error) {
      status = 401 // Unauthorized
      message = "Unauthorized"

    } else if (payload !== referer) {
      status = 401 // Unauthorized
      message = "Not admitted"
    }

    proceed()
  }

  function proceed() {
    if (status) {
      return res.status(status).send({ message })
    }

    next()
  }</b><i>
}


module.exports = {
  getToken</i><b>,
  checkPass</b><i>
}</i></code></pre>
<p>Note that this script includes two <code>console.log()</code>
statements, to help you understand what it is doing.</p>
<ol start="2" type="1">
<li>Edit your <code>backend/router.js</code> file to look like
this:</li>
</ol>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * backend/router.js
 */

const { Router } = require('express')
const router = Router()

</i><b>const { checkPass } = require('./jwToken')

// Ensure that the call came from a client that has already
// connected and received a token.
router.use(checkPass)</b><i>

router.get("/ping", ping)

module.exports = router


function ping(req, res) {
  const { protocol, path, ip } = req
  const { host, origin, referer } = req.headers
  
  const message = `Connection from
referer ${referer}
origin  ${origin}
ip      ${ip}
for     ${protocol}://${host}${path}
at      ${Date()}`

  console.log(message);

  if (res) {
    res.send(`&lt;pre&gt;${message}&lt;/pre&gt;`)
  }
}</i></code></pre>
</details>
</details>
</section>
<!-- Testing the Token -->
<section id="testing-the-token" aria-labelledby="testing-the-token" data-item="Testing The Token">
<h2>
<a href="#testing-the-token">Testing The Token</a>
</h2>
<ol type="1">
<li>Visit <a
href="http://localhost:3000/">http://localhost:3000/</a></li>
<li>Click on the <code>GET /ping</code> button.</li>
</ol>
<p>Everything should work as before. You should see something like the
following in the Terminal window where you ran
<code>npm start</code>:</p>
<pre class="language-bash wrap"><code class="language-bash wrap">referer: http://localhost:3000/
payload: http://localhost:3000/
Connection from
referer http://localhost:3000/
origin  undefined
ip      ::ffff:127.0.0.1
for     http://localhost:3000/ping
at      Wed Nov 20 2024 09:40:47 GMT+0100 (Central European Standard Time)</code></pre>
<p>The <code>referer</code> and the <code>payload</code>. match.</p>
<ol start="3" type="1">
<li>Now type <a
href="http://localhost:3000/ping">http://localhost:3000/ping</a> in the
browser address bar.</li>
</ol>
<p>Before you saw something like:</p>
<figure>
<img src="images/3000_ping.webp" alt="or “Figure 19 revisited”" />
<figcaption aria-hidden="true">or “Figure 19 revisited”</figcaption>
</figure>
<p>Now you get rejected. If you check in the Developer Tools, you’ll see
that the cookie has been set, and that it was sent to the server, and
that the server has responded with a
<code>401 status: Unauthorized.</code></p>
<figure>
<img src="images/3000NotAdmitted.webp" alt="Not Admitted" />
<figcaption aria-hidden="true">Not Admitted</figcaption>
</figure>
<p>You can find the reason in the Terminal where your server is
running:</p>
<pre class="language-bash"><code class="language-bash">referer: undefined , req.path: /ping
payload: http://localhost:3000/</code></pre>
<p>The browser sent no <code>referer</code> header, because the request
came from the browser’s address bar and not from somewhere inside a
loaded web page.</p>
<details class="question" open>
<summary>
Coping with rejection
</summary>
<p>Granted, this technique prevents a visitor from connecting directly
to you the API endpoints of your backend, but it’s not very
user-friendly.</p>
<p>There’s a better solution than sending a
<code>401: Unauthorized</code> message. Can you think of it?</p>
<p>Actually, you’ve already seen what the Vite development server does
when you visit an unknown path. Remember how the frontend behaved when
you originally made a request for <a
href="http://localhost:5173/ping">http://localhost:5173/ping</a> (which
doesn’t exist)?</p>
<figure>
<img src="images/viteping.webp" alt="Figure 14 revisited" />
<figcaption aria-hidden="true">Figure 14 revisited</figcaption>
</figure>
<p>Here’s what I wrote back then:</p>
<blockquote>
<p>Whenever you make a request to the Vite development server, it will
respond with the <code>index.html</code> page, regardless of the path
that you use.</p>
<p><strong>Remember this, because you will be using this insight
later.</strong></p>
</blockquote>
</details>
<details class="pivot" open>
<summary>
Time for Whack-a-mole
</summary>
<p>In a little while, I’ll get you to explore how Router-React-DOM works
when a Vite React frontend is hosted by Express. The solution to the
issues that you’ll encounter there is the same as the solution that you
could use here to make direct API requests more user friendly.</p>
<p>For now, perhaps you’d just like to go outside and take a break and
let your mind wander a bit, so that it can suggest the solution to you
before I tell you.</p>
<p>But first, we’ve got that Whack-a-mole problem to deal with.</p>
</details>
</section>
<!-- Connecting to the API during development -->
<section id="connecting-to-the-api-during-development" aria-labelledby="connecting-to-the-api-during-development" data-item="API at Dev Time">
<h2>
<a href="#connecting-to-the-api-during-development">Connecting To The
API During Development</a>
</h2>
<p>When you publish the frontend and serve it from the
<code>public/</code> directory of your Express server, the technique
you’ve just seen works fine. You set a cookie in the request for
<code>index.html</code> and for all subsequent API requests, you check
that <code>req.header.referer</code> matches the payload of the cookie
token.</p>
<p>But when you are developing, your frontend is delivered by Vite’s
development server which typically runs on port <code>5173</code>. When
you load the <code>index.html</code> page from <a
href="http://localhost:5173">http://localhost:5173</a>, the server at <a
href="http://localhost:5173">http://localhost:3000</a> never gets to see
the request and never sets a cookie.</p>
<p>So when the frontend later makes a request explicitly to <a
href="http://localhost:3000/ping">http://localhost:3000/ping</a>, the
<code>checkPass</code> function says “Hey, there’s no cookie! No token,
no service.”</p>
<p>Try it and see:</p>
<ol type="1">
<li>In your browser visit <a
href="http://localhost:5173">http://localhost:5173</a></li>
<li>Click on the <code>GET /ping</code> button</li>
</ol>
<figure>
<img src="images/frontend403.webp"
alt="The frontend gets a 403 Forbidden response" />
<figcaption aria-hidden="true">The frontend gets a
<code>403 Forbidden</code> response</figcaption>
</figure>
<h2 id="check-if-is_dev-true">Check if <code>IS_DEV</code> ===
<code>"true"</code></h2>
<p>Back in section <a href="#no-cors-in-production">36. No Deployed
CORS</a>, you saw:</p>
<ul>
<li><p>How to set…</p>
<pre class="language-bash line-numbers"><code class="language-bash line-numbers">NODE_ENV=production</code></pre>
<p>… in the <code>backend/.env</code> file</p></li>
<li><p>How to use the <code>dotenv</code> NodeJS package to read in the
value of <code>NODE_ENV</code></p></li>
<li><p>How to use a regular expression to check that the value was
<em>not</em> any of the values conventionally used to indicate
production mode</p></li>
<li><p>How to set a new <em>string</em> value for a
<code>process.env.IS_DEV</code> property.</p></li>
</ul>
<p>Now is the chance to use this custom property.</p>
<h2 id="if-process.env.is_dev-is-set-to-true.">If
<code>process.env.IS_DEV</code> is set to <code>"true"</code>.</h2>
<p>In <code>jwToken.js</code>, you can let any API request go ahead,
even without a valid <code>pass</code>, if the request was made in the
safe development environment.</p>
<ol type="1">
<li>Edit the beginning of your <code>backend/jwToken.js</code> to add a
line to check the value of <code>process.env.IS_DEV</code></li>
<li>Edit the beginning of the <code>checkPass()</code> function, to add
an <code>if ... else statement</code> inside the
<code>if (!pass) {...}</code> block, so that the operation can proceed
during development, even if there is no pass cookie.</li>
</ol>
<p>Your edits should match what you see in the code listing below.</p>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * backend/jwToken.js
 */

const jwt = require("jsonwebtoken")
const JWT_SECRET = process.env.JWT_SECRET || "secret needed"</i>
<b>const is_dev = process.env.IS_DEV === "true"</b></code></pre>
<pre class="skip"><code class="skip">// Some lines skipped</code></pre>
<pre class="language-javascript line-numbers" data-start="32"><code class="language-javascript line-numbers"><i>const checkPass = (req, res, next) =&gt; {
  const pass = req.session?.pass
  const referer = req.headers.referer
  console.log("referer:", referer, ", req.path:", req.path)

  let status = 0
  let message = ""

  if (!pass) {
    </i><b>if (is_dev) {
      console.log(`🤚DEV: PASS ${req.path} GIVEN FOR ${referer}`)

    } else {
      status = 403 // Forbidden
      message = "No pass provided"
    }</b><i>

    proceed()

  } else {
    jwt.verify(pass, JWT_SECRET, treatPass)
  }</i></code></pre>
<pre class="skip"><code class="skip">// all lines to end skipped</code></pre>
<ol start="3" type="1">
<li>In your browser visit <a
href="http://localhost:5173">http://localhost:5173</a> again</li>
<li>Click on the <code>GET /ping</code> button.</li>
</ol>
<p>This time, the API call should work as expected, in “dev” mode.</p>
<figure>
<img src="images/devVitePing.webp"
alt="Successful /ping from frontend in dev mode" />
<figcaption aria-hidden="true">Successful /ping from frontend in dev
mode</figcaption>
</figure>
<ol type="1">
<li>Check the output in the Terminal window where <code>nodemon</code>
is running your server. You should see a line that indicates that the
development frontend was given a free pass, even if it did not send the
expected cookie.</li>
</ol>
<pre class="language-bash"><code class="language-bash">referer: http://localhost:5173/ , req.path: /ping
🤚DEV: PASS /ping GIVEN FOR http://localhost:5173/
Connection from
referer http://localhost:5173/
origin  http://localhost:5173
ip      ::ffff:127.0.0.1
for     http://localhost:3000/ping
at      Thu Nov 28 2024 15:43:57 GMT+0100 (Central European Standard Time)</code></pre>
<p>So development mode is working. But wasn’t there still an issue to
address in production mode?</p>
</section>
<!-- Preview mode -->
<section id="preview-mode" aria-labelledby="preview-mode" data-item="Preview Mode">
<h2>
<a href="#preview-mode">Preview Mode</a>
</h2>
<p>In development mode, you want to run your backend and your frontend
separately, so that a change in one does not require you to update the
other. You want the backend to accept connections from a frontend hosted
at a different <em>origin</em>. Your focus is on expanding and improving
your code, and not on tight security.</p>
<p>In development mode, it’s fine to run <code>npm run publish</code>
from time to time, and check that the Express backend can serve the Vite
React frontend with no problems, but you don’t want to have to
<code>publish</code> all the time.</p>
<p>In <em>production</em> mode, you consider that your frontend code is
stable, and that it’s not going to change until the next release
version. You want the Express server to behave just as it did during
development, but with strong security. You want the backend to ignore
any API requests that don’t reach it through pages that it served for
itself.</p>
<p>And you want your server to run at the chosen origin, on the
<code>PORT</code> that you specify in the production <code>.env</code>
file.</p>
<p>It’s time to check if all this is true. You can do a test in what I’d
like to call <em>preview</em> mode. That is, using the production-level
security, but still in a safe environment.</p>
<ol type="1">
<li>Change the entry for <code>NODE_ENV</code> in the <code>.env</code>
file from <code>dev</code> to <code>production</code></li>
</ol>
<pre class="language-bash line-numbers"><code class="language-bash line-numbers"><b>NODE_ENV=production</b>
<i>PORT=3000
JWT_SECRET=go hang a salami
COOKIE_SECRET=I'm a lasagna hog</i></code></pre>
<ol start="2" type="1">
<li><p>In the Terminal where <code>nodemon</code> is running your
Express server, press <code>^C</code> to cancel the process</p></li>
<li><p>Run <code>npm start</code>to restart your server now that you
have changed the contents of <code>.env</code>.</p></li>
<li><p>In your browser, visit <a
href="http://localhost:3000/">http://localhost:3000/</a></p></li>
<li><p>Click on the <code>GET /ping</code> button</p></li>
</ol>
<figure>
<img src="images/production.webp"
alt="The response to GET /ping in pre-production mode" />
<figcaption aria-hidden="true">The response to GET /ping in
pre-production mode</figcaption>
</figure>
<p>That’s what you would expect to see.</p>
<ol start="6" type="1">
<li>As you did in section <a href="#testing-the-token">50. Testing the
Token</a>, visit <a
href="http://localhost:3000/ping">http://localhost:3000/ping</a></li>
</ol>
<p>As before, you don’t even get a web page. You get a JSON object with
the <code>message: Not admitted</code>.</p>
<figure>
<img src="images/jsonDOA.webp"
alt="A direct API request from the browser address bar gets rejected" />
<figcaption aria-hidden="true">A direct API request from the browser
address bar gets rejected</figcaption>
</figure>
<ol start="7" type="1">
<li>For comparison, now visit the development frontend at <a
href="http://localhost:5173/">http://localhost:5173/</a></li>
<li>Click the <code>GET /ping</code> button</li>
</ol>
<figure>
<img src="images/CORS.webp" alt="or “Figure 15 revisited”" />
<figcaption aria-hidden="true">or “Figure 15 revisited”</figcaption>
</figure>
<p>The Vite development server provides an <code>index.html</code> page
to your browser that does not come from the Express server. In
production mode, there is no CORS validation for any request from any
other source, so the Vite development server has no access at all.</p>
<h2 id="results-and-expectations">Results and expectations</h2>
<p>All the tests above should give you the results that you expected.
Or, to put it another way: you should have been expecting all these
results.</p>
<ol start="9" type="1">
<li>But what happens if you visit <a
href="http://localhost:5173/ping">http://localhost:5173/ping</a>,
though?</li>
</ol>
<figure>
<img src="images/prod5173ping.webp"
alt="A request from http://localhost:5173/ping: the /ping path is ignored" />
<figcaption aria-hidden="true">A request from
http://localhost:5173/ping: the <code>/ping</code> path is
ignored</figcaption>
</figure>
<p>The <code>GET /ping</code> button will still generate a CORS error,
but the page itself looks nothing like the JSON formatted error message
you saw in Figure 29, when a request was made for <a
href="http://localhost:3000/ping">http://localhost:3000/ping</a>.</p>
<p>The Vite development server <em>ignores the <code>/ping</code>
path</em> and returns exactly the same <code>index.html</code> file as
when you visited <a
href="http://localhost:5173/">http://localhost:5173/</a> just now.</p>
<p>This is more polite, isn’t it?</p>
<h2 id="what-about-a-different-port">What about a different port?</h2>
<p>I wrote above:</p>
<blockquote>
<p>And you want your server to run at the chosen origin, on the
<code>PORT</code> that you specify in the <code>.env</code> file.</p>
</blockquote>
<p>As you have just seen, it certainly works on port 3000. It’s time to
change that.</p>
<ol type="1">
<li>In the <code>backend/.env</code>, change the setting for
<code>PORT</code> to <code>3333</code></li>
</ol>
<pre class="language-bash line-numbers"><code class="language-bash line-numbers"><i>NODE_ENV=production
</i><b>PORT=3333</b><i>
JWT_SECRET=go hang a salami
COOKIE_SECRET=I'm a lasagna hog</i></code></pre>
<ol start="2" type="1">
<li>Stop your backend server and restart it as you did in steps 2 and 3
above.</li>
<li>Visit <a
href="http://localhost:3000/">http://localhost:3000/</a></li>
</ol>
<p>It shouldn’t surprise you that you can’t connect to your server on
port 3000 any more.</p>
<figure>
<img src="images/unableToConnect.webp" alt="Unable to Connect" />
<figcaption aria-hidden="true">Unable to Connect</figcaption>
</figure>
<ol start="3" type="1">
<li>Visit <a href="http://localhost:3333/">http://localhost:3333/</a>
instead (which should work fine) …</li>
<li>… and click on <code>GET /ping</code></li>
<li>You get another CORS error. But isn’t the <code>/ping</code> request
coming from an official page, served by the Express server itself?</li>
</ol>
<figure>
<img src="images/pingFails.webp"
alt="GET /ping fails if the PORT is changed" />
<figcaption aria-hidden="true">GET /ping fails if the PORT is
changed</figcaption>
</figure>
<p>I’d warned you about this earlier, back in section <a
href="#just-one-more-thing">40. Just One More Thing</a>. Remember?</p>
<blockquote>
<p>Oh… but first, now there’s another issue. You can see it if you:</p>
<ol type="1">
<li>Run <code>npm run publish</code> in the parent directory</li>
<li>Reload <a href="http://localhost:3000">http://localhost:3000</a> in
your browser</li>
</ol>
<p><img src="images/local_origin.webp" /></p>
<p>Do you see it? The value that the frontend is using for
<code>ORIGIN</code> has been logged to the Console. Sure, it’s the right
value. But… where was it set? Why was it set? Won’t it ever change?</p>
<p>In the files that Vite created during the <code>build</code> process,
the value for <code>import.meta.env.VITE_ORIGIN</code> has been
hard-coded in.</p>
</blockquote>
<p>And now you can see that it matters.</p>
</section>
<!-- Using the Right ORIGIN -->
<section id="using-the-right-origin" aria-labelledby="using-the-right-origin" data-item="The Right ORIGIN">
<h2>
<a href="#using-the-right-origin">Using the Right ORIGIN in Production
Mode</a>
</h2>
<p>The problem is occurring in the frontend code, in the
<code>Ping.jsx</code> component.</p>
<p>The frontend doesn’t know when it’s being served by the Vite
development server or by your Express backend, so you have to give a way
to find out.</p>
<p>By default, Vite will use port <code>5173</code> for the frontend
development server. However, if you happen to have more than one Vite
frontend running, it will use port <code>5174</code> or
<code>5175</code> or whichever is the next free port number.</p>
<p>The solution is to check if the frontend is running at
<code>localhost:517X</code>, where ‘X’ is a number. If it is, then the
chances are that the frontend is running in development mode. In this
case, yes, you do want to use the value of <code>VITE_ORIGIN</code> that
was stored in the <code>frontend/.env</code> file.</p>
<p>If the frontend is <em>not</em> running in development mode, then you
want to use <code>""</code> instead of this hard-coded value of
<code>import.meta.env.VITE_ORIGIN</code>.</p>
<ol type="1">
<li>Fix the <code>frontend/src/components/Ping.jsx</code> script by
adding the lines shown in Listing 70 below.</li>
</ol>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * frontend/src/components/Ping.jsx
 */

import React, { useState } from 'react'
const TAG_REGEX = /(&lt;.*?&gt;)|(&lt;\/.*?&gt;)/g
const ORIGIN = import.meta.env.VITE_ORIGIN
</i><b>const dev = /^localhost:517\d$/.test(window.location.host)
const origin = dev ? ORIGIN : "" // "" in production mode

console.log("ORIGIN:", ORIGIN);
console.log("dev:", dev);
console.log("origin:", origin)</b><i>

export const Ping = () =&gt; {
  const [ response, setResponse ] = useState("")

  const getPing = () =&gt; {
    fetch(`${origin}/ping`)
      .then(incoming =&gt; incoming.text())
      // Always sanitize data from unreliable sources
      .then(text =&gt; text.replace(TAG_REGEX, ""))
      .then(text =&gt; setResponse(text))
      .catch(error =&gt; setResponse(error.message))
  }

  return (
    &lt;&gt;
      &lt;button
        onClick={getPing}
      &gt;
        GET /ping
      &lt;/button&gt;
      &lt;pre&gt;
        {response}
      &lt;/pre&gt;
    &lt;/&gt;
  )
}</i></code></pre>
<ol start="2" type="1">
<li>From a Terminal active in the parent folder of your project, run
<code>npm run publish</code></li>
<li>Visit <a
href="http://localhost:3000/">http://localhost:3000/</a>again</li>
<li>Click on the <code>GET /ping</code> button.</li>
</ol>
<figure>
<img src="images/pingSuccess.webp"
alt="A successful API request to /ping in production" />
<figcaption aria-hidden="true">A successful API request to
<code>/ping</code> in production</figcaption>
</figure>
<p>And now, your production backend works as expected, regardless of its
domain name and port number, and regardless of which backend server the
development frontend expected to connect to.</p>
<h2 id="back-to-dev-mode">Back to <code>dev</code> mode</h2>
<p>If all the tests that you ran above worked the way I explained that
they should, then switch your backend back to development mode.</p>
<ol type="1">
<li>Reset the file at <code>backend/.env</code>, so that it uses the
values that your development frontend is expecting</li>
</ol>
<pre class="language-bash line-numbers"><code class="language-bash line-numbers"><b>NODE_ENV=dev
PORT=3000</b>
<i>JWT_SECRET=go hang a salami
COOKIE_SECRET=I'm a lasagna hog</i></code></pre>
<ol start="2" type="1">
<li>Restart the backend server, so that it will read in the reset values
from <code>.env</code>.</li>
</ol>
<details class="pivot" open>
<summary>
A more complex frontend
</summary>
<p>So far, I’ve kept the frontend as simple as possible, with just
enough functionality to test that a backend Express server can be used
to serve up a React frontend built with Vite. In the next chapter, you
can create a more complex frontend, and see if any adjustments will
needed in the backend.</p>
</details>
</section>
<!-- Creating pages with React Router DOM -->
<section id="creating-pages-with-react-router-dom" aria-labelledby="creating-pages-with-react-router-dom" data-item="A Multiple Page App">
<h2>
<a href="#creating-pages-with-react-router-dom">Creating a Multiple Page
App With React Router DOM</a>
</h2>
<p>React gives you powerful tools to build a frontend from custom
JavaScript, all contained in a single HTML page. This <em>single page
app</em> can remember the results of all the clicks and edits and
interactions of the end-user, and store them locally as <em>state</em>
or <em>context</em>.</p>
<p>A React app can also pretend to navigate to other URLs, without
actually changing the page. This is known as <em>routing</em> .</p>
<p>With routing, a React app can:</p>
<ul>
<li>Update its display, depending on the URL that the end-user types in
the address bar</li>
<li>Update the URL in the address bar as the end-user visits different
parts of the app.</li>
<li>Provide links between the different sections of the app, that make
it appear to navigate to a different page.</li>
</ul>
<p>Copying the URL that is currently displayed and pasting it as the
address in a new browser tab should display the app in exactly the same
state in both tabs.</p>
<h2 id="working-with-react-router-dom">Working with
React-Router-DOM</h2>
<p>In this part, I’ll show you how the Vite development server and the
<a href="https://reactrouter.com/home"><code>react-router-dom</code></a>
NodeJS package work together to create this simulation of multiple
pages. And you’ll see that your Express backend works in a different way
by default, but you can teach it to work in same way, with only a small
tweak.</p>
<p>In development mode, you’ll create a second “page” for your single
page app, and use either links or direct typing in the browser’s address
bar to move between the two pages. You’ll also see what happens if you
type in a path that your single page app does not recognize.</p>
<p>And then you’ll test this in “production” mode using your Express
backend, and work out how to tweak your backend so that it gives you the
same behaviour.</p>
<details class="warn" open>
<summary>
No in-depth explanations of React-Router-DOM
</summary>
<p>In this tutorial, I will not explain how
<code>react-router-dom</code> works or how to use it to good advantage
in your own projects. I will assume that you already know about this
from other sources.</p>
<p>My purpose here is simply to give you enough information to get your
Express backend to work with <code>react-router-dom</code> the same way
that the Vite development server works.</p>
</details>
</section>
<!-- react router dom -->
<section id="react-router-dom" aria-labelledby="react-router-dom" data-item="react-router-dom">
<h2>
<a href="#react-router-dom"><code>react-router-dom</code></a>
</h2>
<p>First you need to <code>react-router-dom</code> to your frontend
project:</p>
<ol type="1">
<li>Open a Terminal on your <code>frontend/</code> directory</li>
<li>Run the command</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">npm i react-router-dom</code></pre>
<p>This is how your Terminal should appear:</p>
<pre class="language-bash"><code class="language-bash"><b>npm i react-router-dom</b>

added 6 packages, and audited 256 packages in 744ms

102 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities</code></pre>
<h2 id="adding-frontend-routes">Adding frontend routes</h2>
<p>To create two frontend routes, you’re going to need to:</p>
<ul>
<li>Create a <em>page</em> component for each route that will be
displayed</li>
<li>Create a hierarchy of <code>&lt;Router&gt;</code>,
<code>&lt;Routes&gt;</code> and <code>&lt;Route&gt;</code> tags inside
the <code>App.jsx</code> script.</li>
</ul>
<ol type="1">
<li>Start by creating a new file at
<code>frontend/src/pages/Page1.jsx</code></li>
<li>Give it the boilerplace script that you can see below.</li>
</ol>
<pre class="language-jsx line-numbers"><code class="language-jsx line-numbers">/**
 * frontend/src/pages/Page1.jsx
 */

import React from 'react'
import { Link } from 'react-router-dom'

export const Page1 = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;Page 1 goes here&lt;/h1&gt;
      &lt;Link to="/page2" draggable="false"&gt;Page 2&lt;/Link&gt;
      &lt;Link to="/ping"  draggable="false"&gt;Ping&lt;/Link&gt;
    &lt;/&gt;
  )
}</code></pre>
<ol type="1">
<li>Create a second file, in the same folder, at
<code>frontend/src/pages/Page2.jsx</code></li>
<li>Give it the boilerplace script that you can find below.</li>
</ol>
<pre class="language-jsx line-numbers"><code class="language-jsx line-numbers">/**
 * frontend/src/pages/Page2.jsx
 */

import React from 'react'
import { Link } from 'react-router-dom'

export const Page2 = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;This is Page 2&lt;/h1&gt;
      &lt;Link to="/page1" draggable="false"&gt;Page 1&lt;/Link&gt;
      &lt;Link to="/ping"  draggable="false"&gt;Ping&lt;/Link&gt;
    &lt;/&gt;
  )
}</code></pre>
<ol start="4" type="1">
<li>Create a new file at
<code>frontend/src/pages/NotFound.jsx</code></li>
<li>Give it the boilerplace script that you see below. This will appear
as a fallback page if the end-user tries to visit a page that does not
exist.</li>
</ol>
<pre class="language-jsx line-numbers"><code class="language-jsx line-numbers">/**
 * frontend/src/pages/NotFound.jsx
 */

import React from 'react'
import { Link } from 'react-router-dom'
  
export const NotFound = () =&gt; {  
  return (
    &lt;&gt;
      &lt;h1&gt;Page not found&lt;/h1&gt;
      &lt;Link to="/" draggable="false"&gt;Go to Page 1&lt;/Link&gt;
    &lt;/&gt;
  )
}</code></pre>
<ol type="1">
<li>Replace the script of the file at <code>frontend/src/App.jsx</code>
with the code below:</li>
</ol>
<pre class="language-jsx line-numbers"><code class="language-jsx line-numbers"><i>/**
 * frontend/src/App.jsx
 */</i>
 
<b>import {
  BrowserRouter as Router,
  Routes,
  Route
} from 'react-router-dom'</b>
<i>import './App.css'
import { Ping } from './components/Ping'</i>
<b>import { Page1 } from './pages/Page1'
import { Page2 } from './pages/Page2'
import { NotFound } from './pages/NotFound'</b>

<i>function App() {
  return (</i>
    <b>&lt;Router&gt;
      &lt;Routes&gt;
        &lt;Route index element={&lt;Page1 /&gt;} /&gt;
        &lt;Route path="/page1" element={&lt;Page1 /&gt;} /&gt;
        &lt;Route path="/page2" element={&lt;Page2 /&gt;} /&gt;
        &lt;Route path="/ping" element={&lt;Ping /&gt;} /&gt;
        &lt;Route path="*" element={&lt;NotFound /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/Router&gt;</b><i>
  )
}

export default App</i></code></pre>
<ol start="7" type="1">
<li>Add styling for links to <code>frontend/src/App.css</code></li>
</ol>
<pre class="language-css line-numbers"><code class="language-css line-numbers"><i>/**
 * frontend/src/App.css
 */

 pre {
  border: 1px inset #888;
  width: fit-content;
  min-width: 25em;
  min-height: 7em;
  overflow: auto;
}</i>

<b>a {
  display: block;
  width: 7em;
  padding: 0.25em 1em;
  text-align: center;
  border: 1px outset #888;
  border-radius: 0.5em;
  user-select: none;

  &:hover:active {
    border-style: inset;
    background-color: #000;
  }
}</b></code></pre>
<h2 id="testing-the-routes">Testing the routes</h2>
<ol type="1">
<li>Visit the development frontend at <a
href="http://localhost:5173">http://localhost:5173</a></li>
<li>Click on the Link to <a href="http://localhost:5173/page2">Page
2</a></li>
</ol>
<figure>
<img src="images/LinkPage2.webp" alt="Link to Page 2" />
<figcaption aria-hidden="true">Link to Page 2</figcaption>
</figure>
<ol start="3" type="1">
<li>Notice how the contents of the page changes, and how the URL in the
address updates to match the link that was clicked.</li>
</ol>
<figure>
<img src="images/page2.webp" alt="Page 2" />
<figcaption aria-hidden="true">Page 2</figcaption>
</figure>
<p>Use different methods to move back and forth between these two pages:
4. Use the anchor links in the pages 5. Use the back ⬅️ and ➡️ forward
buttons in the browser address bar 6. Click in the browser address bar
and press Enter to reload the page 7. Press the <code>Ctrl-R</code>
shortcut to reload the current page</p>
<h2 id="an-unknown-path">An unknown path?</h2>
<ol start="8" type="1">
<li>Type an unknown path like <a
href="http://localhost:5173/unknown">http://localhost:5173/unknown</a>
into your browser’s address bar.</li>
</ol>
<figure>
<img src="images/notFound.webp"
alt="There is no page with the path /unknown" />
<figcaption aria-hidden="true">There is no page with the path
<code>/unknown</code></figcaption>
</figure>
<p>You should find yourself on the Not Found page, with a link back to
Page 1.</p>
<details class="pivot" open>
<summary>
Can Express handle this?
</summary>
<p>Everything should work as you would expect in development mode. But
will it break when your published React files are served by your Express
backend?</p>
<p>SPOILER ALERT: yes, it will break.</p>
</details>
</section>
<!-- Frontend pages from Express -->
<section id="frontend-pages-from-express" aria-labelledby="frontend-pages-from-express" data-item="Express for Frontend">
<h2>
<a href="#frontend-pages-from-express">Frontend Pages From Express</a>
</h2>
<p>It’s time to see what breaks when the published React frontend is
served from your Express backend.</p>
<ol type="1">
<li>In a Terminal that is active in the parent directory, run
<code>npm run publish</code></li>
<li>Visit the Express server at <a
href="http://localhost:3000">http://localhost:3000</a></li>
<li>Click on the Link to <a
href="http://localhost:3000/page2">Page2</a></li>
<li>Notice how, as before, the contents of the page changes, and how the
URL in the address updates to match the link that was clicked.</li>
<li>Use the link buttons to move back and forth between Page 1 and Page
2</li>
<li>Use the back ⬅️ and ➡️ forward buttons in the browser address
bar</li>
</ol>
<p>All this should work fine. Now to see where things break. All of the
following will fail the same way:</p>
<ol start="8" type="1">
<li>Click in the browser address bar and press Enter to reload the
page</li>
<li>Press the <code>Ctrl-R</code> shortcut to reload the current
page</li>
<li>Type an unknown path like <a
href="http://localhost:3000/uncharted">http://localhost:3000/uncharted</a>
into your browser’s address bar.</li>
<li>Click on the link for <code>Ping</code> then click on the GET /ping
button</li>
</ol>
<figure>
<img src="images/notAdmitted.webp"
alt="Many actions are Not admitted when the React site is served by Express" />
<figcaption aria-hidden="true">Many actions are
<code>Not admitted</code> when the React site is served by
Express</figcaption>
</figure>
</section>
<!-- Server Differences -->
<section id="server-differences" aria-labelledby="server-differences" data-item="Server Differences">
<h2>
<a href="#server-differences">How Express is different from the Vite
development server</a>
</h2>
<p>As you may have noticed, the Vite development server always serves
the <code>index.html</code> page, even when you define a custom path. If
you are not using a client-side router like
<code>react-router-dom</code>, the display in the browser will not
change. When you add client-side routing with
<code>react-router-dom</code>, it is the JavaScript in the browser that
changes the display and the URL in the address bar.</p>
<p>Your Express router works differently.</p>
<ul>
<li>If there is a file that matches the request in the
<code>public/</code> folder, it will serve that.</li>
<li>If there is an API route that matches the <code>path</code> part of
the requested URL, it will do what it can to respond to that.</li>
<li>If there is no route matching the path, the <code>checkPass()</code>
function in the <code>jwToken.js</code> script will send a 40X “invalid
path” message, like the ones you have just seen.</li>
</ul>
<h2 id="making-express-behave-like-the-vite-development-server">Making
Express behave like the Vite development server</h2>
<p>Instead of sending a 40X “invalid path” message, you can make your
Express server return the <code>index.html</code> page, just like the
Vite development server does, if the <code>payload</code> does not match
the <code>referer</code>.</p>
<p>Edit the <code>backend/jwToken.js</code> script to:</p>
<ol type="1">
<li>Add two lines at the beginning to generate the absolute path to the
file at <code>backend/public/index.html</code></li>
<li>Change the way the <code>treatPass()</code> function deals with
errors or invalid API requests. Specifically: use
<code>res.sendFile(index)</code> if the API request was invalid in any
way, but allow it to proceed if no irregularity was found.</li>
</ol>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * backend/jwToken.js
 */</i>

<b>const { join } = require('path')
const INDEX_HTML = join(process.cwd(), 'public/index.html')</b>

const jwt = require("jsonwebtoken")
const JWT_SECRET = process.env.JWT_SECRET || "secret needed"
const is_dev = process.env.IS_DEV === "true"</code></pre>
<pre class="skip"><code class="skip">// Some lines skipped</code></pre>
<pre class="language-js line-numbers" data-start="59"><code class="language-js line-numbers"><i>  function treatPass(error, payload) {
    console.log("payload:", payload)</i>

    <b>const sendHome = 
       error    // the JWT token was invalid
    || !referer // the request did not come from a page
    || referer && !referer.startsWith(payload) // invalid referer

    if (sendHome) {
      // Ignore API request: respond with index.html file 
      return res.sendFile(INDEX_HTML)
    }</b>

    <i>proceed() // with API request
  }</i></code></pre>
<pre class="skip"><code class="skip">// all lines to the end skipped</code></pre>
<p>The line <code>return res.sendFile(index)</code> instructs your
server to treat all unknown requests as a request for the <code>/</code>
site root, which delivers the <code>index.html</code> page. This means
that the JavaScript in the frontend can deal with the display and the
URL to show in the browser’s address bar, just as it does with the Vite
development server…</p>
<h2 id="the-referer-has-changed">The <code>referer</code> has
changed</h2>
<p>Did you notice this expression:
<code>!referer.startsWith(payload)</code>? That’s new. Before, you
checked if <code>payload !== referer</code>. It might be good to take a
close look at the value <code>referer</code> in the request for the
<code>/ping</code> API route.</p>
<ol type="1">
<li>Click on the link for <code>Ping</code></li>
<li>Click on the <code>GET /ping</code> button</li>
</ol>
<figure>
<img src="images/referer.webp"
alt="The referer now reflects the URL in the browser’s address bar" />
<figcaption aria-hidden="true">The referer now reflects the URL in the
browser’s address bar</figcaption>
</figure>
<p>Do you see that? Earlier, when you weren’t using
<code>react-router-dom</code> to generate client-side routes, the
<code>referer</code> was simply <code>http://localhost:3000</code>. Now
it’s <code>http://localhost:3000/ping</code>.</p>
<p>Here’s what it looked like before:</p>
<figure>
<img src="images/localping.webp" alt="or “Figure 13 revisited”" />
<figcaption aria-hidden="true">or “Figure 13 revisited”</figcaption>
</figure>
<p>Now, if you look in the Terminal where <code>nodemon</code> is
running your Express server, you will see that the <code>referer</code>
contains the <code>/ping</code> path, because of the way
<code>react-router-dom</code> updates URLs in the browser:</p>
<pre class="language-bash"><code class="language-bash">referer: http://localhost:3000/ping , req.path: /ping
payload: http://localhost:3000/</code></pre>
<p>In other words, the <code>referer</code> string is longer than the
expected value that is stored in <code>payload</code>. Instead of
comparing the two values exactly, you can check if
<code>referer.startsWith(payload)</code>. If it does, then the server
can be sure that the request is legitimate.</p>
</section>
<!-- Treating 404 in browser -->
<section id="treating-404-in-browser" aria-labelledby="treating-404-in-browser" data-item="404 in the Browser">
<h2>
<a href="#treating-404-in-browser">Treating 404 in the Browser</a>
</h2>
<p>One final test: what happens if you enter a non-existent
<code>path</code> in the browser address bar? Try it.</p>
<ol type="1">
<li>In the browser address bar, visit <a
href="http://localhost:3000/pingo">http://localhost:3000/pingo</a>, or
any other path that is not explicitly treated as a client-side route or
API route.</li>
</ol>
<figure>
<img src="images/pingo.webp"
alt="Elegantly handling an unknown route" />
<figcaption aria-hidden="true">Elegantly handling an unknown
route</figcaption>
</figure>
<p>All is well. The Page Not Found page is shown.</p>
<details class="pivot" open>
<summary>
Ready to Deploy
</summary>
<p>You now have a project built with a React frontend using Vite and an
Express backend. You have ensured that its features work as expected in
development mode and in a preview of production mode. You can visit
different “pages” in the browser and fetch data from the backend.</p>
<p>Aesthetically, it’s not going to fascinate your friends, family and
colleagues, but technically, it’s a solid achievement.</p>
<p>The next step will be to deploy this proof-of-concept project to a
server on a hosting web site.</p>
</details>
</section>
<!-- Deploy to Render.com -->
<section id="deploy-to-host" aria-labelledby="deploy-to-host" data-item="Ready to Deploy">
<h1>
<a href="#deploy-to-host">Part 3: Deploying to a Hosting Site</a>
</h1>
<p>It looks as if your proof-of-concept React site served by Express is
ready for deployment.</p>
<p>SPOILER ALERT: It’s not. A deployed site will use the secure HTTPS
protocol. Can you guess where this will make your server fail when it’s
deployed?</p>
<p>Below, I’ll describe the steps that I use to deploy my server to the
free tier on <a href="https://render.com/">Render.com</a> from a <a
href="https://github.com/">GitHub</a> repository.</p>
<p>In order to deploy to a hosting service, you will need to work in two
phases:</p>
<h3 id="phase-1-create-a-github-repository">Phase 1: Create a GitHub
<em>repository</em></h3>
<ul>
<li>Have an account on GitHub.com</li>
<li>Create a repository for your backend on your local computer</li>
<li><code>push</code> your repository to GitHub.com</li>
</ul>
<h3 id="phase-2-deploy-to-render.cm">Phase 2: Deploy to Render.cm</h3>
<ul>
<li>Create an account on Render.com</li>
<li>Create a new Web Service on Render.com</li>
<li>Connect your Web Service to your GitHub repository</li>
<li>Enter some settings details</li>
<li>Click on a Deploy Web Service button</li>
</ul>
<h2 id="git-and-github">Git and GitHub</h2>
<p><a href="https://git-scm.com/">Git</a> is a distributed version
control system that allows you to create a <em>repository</em> for each
of your projects. It allows you to create backups at key points in
development, and to test new features without breaking stable code.</p>
<p><a href="https://github.com/">GitHub</a> is a service now owned by
Microsoft. It allows you to store repositories of your repositories in a
safe space online. You can think of it as a powerful backup system,
which gives other developers the chance to collaborate with you on your
projects.</p>
<p>I’ll assume that if you have got this far, you already know about
GitHub and the Git distributed version control system. If not:</p>
<ul>
<li><a href="https://git-scm.com/downloads">Download and install Git</a>
for your operating system</li>
<li>Visit the <a href="github.com/signup">GitHub Signup page</a> and
follow the instructions.</li>
</ul>
<p>After you run <code>npm run publish</code>, all the code and assets
that you need for your Vite-React + Express project are contained in
your <code>backend/</code> directory.</p>
<h2 id="creating-a-git-repository-of-your-backend-directory">Creating a
Git repository of your backend directory</h2>
<p>To create a Git repository of your <code>backend/</code>
directory:</p>
<ol type="1">
<li>Open a Terminal window in your <code>backend/</code> directory</li>
<li>Run <code>git init</code></li>
</ol>
<pre class="language-bash"><code class="language-bash">$ git init                                   
Initialized empty Git repository in /path/to/backend/.git/</code></pre>
<ol start="3" type="1">
<li><p>Create a <code>.gitignore</code> file with the following
contents:</p>
<pre class="language-bash wrap"><code class="language-bash wrap">node_modules/
.env
.vscode/*
!.vscode/extensions.json
.DS_Store
Icon?
![iI]con[_a-zA-Z0-9-]</code></pre>
<p>This will ensure that the Git repository will not store any
unnecessary or private data. Specifically:</p>
<ul>
<li>Your <code>backend/node_modules/</code> will be huge, and your
<code>package.json</code> and <code>package-lock.json</code> files
already contain all the information necessary to recreate it. It is a
waste of resources to include <code>node_modules/</code> in your Git
repository.</li>
<li>Your <code>.env</code> file contains secrets that you don’t want to
share.</li>
<li>The remaining entries in the <code>.gitignore</code> file are not
critical. Some are personal developer settings; some are generated only
in certain circumstances on MacOS and developers on other platforms will
consider them like spam.</li>
</ul></li>
<li><p>Run
<code>git add . &amp;&amp; git commit -m "Initial commit"</code></p></li>
</ol>
<pre class="language-bash"><code class="language-bash"><b>git add . && git commit -m "Initial commit"</b>
[main (root-commit) 2d91860] Initial commit
 11 files changed, 1314 insertions(+)
 create mode 100644 .gitignore
 create mode 100644 jwToken.js
 create mode 100644 package-lock.json
 create mode 100644 package.json
 create mode 100644 public/assets/index-BZVNIzQ0.js
 create mode 100644 public/assets/index-DJaG3xuZ.css
 create mode 100644 public/index.html
 create mode 100644 public/vite.svg
 create mode 100644 router.js
 create mode 100644 serveCookie.js
 create mode 100644 server.js</code></pre>
<h2 id="a-public-repository-on-github">A public repository on
GitHub</h2>
<p>To share this local repository online:</p>
<ol type="1">
<li>Visit your GitHub account</li>
<li>Click on the Repositories tab</li>
<li>Click on the green New Repository button</li>
</ol>
<figure>
<img src="images/NewRepo.webp" alt="Creating a New Repo" />
<figcaption aria-hidden="true">Creating a New Repo</figcaption>
</figure>
<ol start="4" type="1">
<li>Fill in the repository name and select the Public radio button, and
press Create Repository</li>
</ol>
<figure>
<img src="images/CreateRepo.webp"
alt="Filling in the form for a new repository" />
<figcaption aria-hidden="true">Filling in the form for a new
repository</figcaption>
</figure>
<ol start="5" type="1">
<li>On the following page, scroll to the end and copy the three
<code>bash</code> commands in the “push an existing repository”
section.</li>
</ol>
<figure>
<img src="images/PushExisting.webp"
alt="The code to push an existing repo" />
<figcaption aria-hidden="true">The code to <code>push</code> an existing
repo</figcaption>
</figure>
<ol start="6" type="1">
<li>In the Terminal window open on your <code>backend/</code> directory,
paste the lines that you have just copied (remember:
<code>Ctrl-Shift-V</code>):</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap"><b>git remote add origin git@github.com:&lt;you&gt;/&lt;repo&gt;.git
git branch -M main
git push -u origin main</b>
Enumerating objects: 17, done.
Counting objects: 100% (17/17), done.
Delta compression using up to 10 threads
Compressing objects: 100% (17/17), done.
Writing objects: 100% (17/17), 72.12 KiB | 6.01 MiB/s, done.
Total 17 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
To github.com:&lt;you&gt;/&lt;repo&gt;.git
 * [new branch]      main -&gt; main
branch 'main' set up to track 'origin/main'.</code></pre>
<ol start="7" type="1">
<li>Back in your browser, refresh the page for your new repository.</li>
<li>You should see a big green button with the name
<code>&lt;&gt; Code</code>. Click on that. The page should display a
dialog that lets you copy the link to your repository that you will need
for Render.com.</li>
</ol>
<figure>
<img src="images/CloneCode.webp" alt="The big green Code button" />
<figcaption aria-hidden="true">The big green Code button</figcaption>
</figure>
</section>
<!-- Deploy to Render.com -->
<section id="deploy-to-render-com" aria-labelledby="deploy-to-render-com" data-item="Deploying">
<h2>
<a href="#deploy-to-render-com">Deploying To render.com</a>
</h2>
<h2 id="create-an-account-on-render.com">Create an account on
Render.com</h2>
<p>If you don’t already have an account on Render.com: 1. Visit <a
href="https://render.com/">Render.com</a> 2. Click on the Get Started
For Free button</p>
<figure>
<img src="images/RenderFree.webp" alt="Choose Get Started for Free" />
<figcaption aria-hidden="true">Choose Get Started for Free</figcaption>
</figure>
<ol start="3" type="1">
<li>Create an account. The easiest way is to link to your GitHub
account.</li>
</ol>
<figure>
<img src="images/CreateAccount.webp"
alt="Fill in the Create Account form" />
<figcaption aria-hidden="true">Fill in the Create Account
form</figcaption>
</figure>
<ol start="4" type="1">
<li>On the next page, click on the + New button and then select Web
Service from the drop-down menu:</li>
</ol>
<figure>
<img src="images/NewWebService.webp" alt="Create a New Web Service" />
<figcaption aria-hidden="true">Create a New Web Service</figcaption>
</figure>
<ol start="5" type="1">
<li>The next page asks you for lots of data, starting with the link to
your GitHub repository. You can find this by clicking the green &lt;&gt;
Code button in your GitHub repo page, as shown in Figure 45 at the end
of the <a href="#deploy-to-host">previous section</a>.</li>
</ol>
<figure>
<img src="images/GitRepo.webp" alt="GitRepo" />
<figcaption aria-hidden="true">GitRepo</figcaption>
</figure>
<ol start="6" type="1">
<li>Next, you’ll be asked how Render.com should install all your NodeJS
package dependencies and start your server.
<ul>
<li>For <strong>Build Command</strong>, can change this to the
<code>npm install</code> that you are used to. The default
<code>yarn</code> setting will work, but it will complain at you for not
using <code>yarn</code> during development.</li>
<li>For <strong>Start Command</strong>, you should use
<code>node server.js</code>. The Render.com site will take care of
restarting your server if it fails. <code>nodemon</code> is therefore
not necessary.</li>
<li>For the <strong>Instance Type</strong>, you can choose the Free
option</li>
</ul></li>
</ol>
<figure>
<img src="images/CommandsTier.webp"
alt="Choosing the Build and Start commands;" />
<figcaption aria-hidden="true">Choosing the Build and Start
commands;</figcaption>
</figure>
<ol start="7" type="1">
<li><p>You will also need to add three Environment Variables. You can
import these from your <code>backend/.env</code> file.</p>
<p><strong>Important: Ensure that the value you use for
<code>NODE_ENV</code> is <code>production</code></strong></p></li>
</ol>
<figure>
<img src="images/EnvDeploy.webp"
alt="Setting the Environment Variables" />
<figcaption aria-hidden="true">Setting the Environment
Variables</figcaption>
</figure>
<ol start="8" type="1">
<li>Click on Deploy Web Service</li>
</ol>
<p>Render.com will take you to a new page where you see feedback on the
installation, build and deployment process. Eventually it will tell you
that <strong>Your service is live 🎉</strong>.</p>
<p>You’ll find a link to your deployed web service near the top left of
the page.</p>
<figure>
<img src="images/Live.webp" alt="A Link to your Live Web Service" />
<figcaption aria-hidden="true">A Link to your Live Web
Service</figcaption>
</figure>
<ol start="9" type="1">
<li>Click on the link, and check that the Page 1, Page 2 and Ping links
all behave as you would expect.</li>
<li>When you click on the <code>GET /ping</code> button, though, you’ll
be disappointed.</li>
</ol>
<figure>
<img src="images/FailedPing.webp"
alt="The GET /ping Button Will Fail" />
<figcaption aria-hidden="true">The GET /ping Button Will
Fail</figcaption>
</figure>
<p>Instead of responding with the output of the <code>/ping</code>
function, the deployed server responds with the contents of the
<code>index.html</code> file, stripped of all its tags.</p>
<p>If you look in the output on the page on Render.com where you
deployed your server, you should see these clues about what is going
wrong:</p>
<pre class="language-bash wrap"><code class="language-bash wrap">Server listening at http://localhost:10000
origin: http://vite-react-express.onrender.com/</code></pre>
<pre class="skip"><code class="skip"># Lines skipped</code></pre>
<pre class="language-bash wrap"><code class="language-bash wrap">referer: https://vite-react-express.onrender.com/ping
payload: http://vite-react-express.onrender.com/</code></pre>
<p>The server that you wrote is running in the insecure HTTP mode, but
Render.com has wrapped it with a secure HTTPS reverse proxy. As a
result, the payload in your cookie is being set with the
<code>http</code> protocol, because that’s what <code>server.js</code>
thinks its protocol is. But the <code>referer</code> contains the
<code>https</code> protocol set up by Render.com’s reverse proxy.</p>
<details class="note" open>
<summary>
Which PORT?
</summary>
<p>Notice also that Render.com has set the value of
<code>process.env.PORT</code> to <code>10000</code>. Your default of
<code>3000</code> has been ignored.</p>
</details>
<details class="pivot" open>
<summary>
Final fixes
</summary>
<p>It looks like you are going to have to make an adjustment for this.
Whatever you change, it must still work with the <code>http</code>
protocol that you are using for development.</p>
</details>
</section>
<!-- Fixing the cookie `payload` -->
<section id="fixing-the-cookie-payload" aria-labelledby="fixing-the-cookie-payload" data-item="The Cookie `Payload`">
<h2>
<a href="#fixing-the-cookie-payload">Fixing The Cookie
<code>Payload</code></a>
</h2>
<p>During development, you want to check that the <code>referer</code>
is using the <code>http</code> protocol, just like your Express server
does. In production, the <code>referer</code> will be using the
<code>https</code> protocol, even if your Express server itself is
not.</p>
<h2 id="matching-with-a-regular-expression">Matching with a regular
expression</h2>
<p>One way to fix this would to use a Regular Expression as the
<code>payload</code> for the cookie that your server sets. Here’s a
Regular Expression that matches URLS with either the <code>https</code>
protocol or the <code>http</code> protocol, so long as the domain is
<code>localhost</code>. Click on the expression to visit a site where
you can test it.</p>
<p><a
href="https://regex101.com/r/9Oyv8D/1"><code>/^https?:\/\/localhost:3000\//i</code></a></p>
<p>This can be understood as follows:</p>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr>
<th>Characters</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/</code></td>
<td>Indicates the start (and the end) of the Regular Expression</td>
</tr>
<tr>
<td><code>^</code></td>
<td>Starts matching from the beginning of the string</td>
</tr>
<tr>
<td><code>http</code></td>
<td>Matches a string the exact string <code>http</code></td>
</tr>
<tr>
<td><code>s?</code></td>
<td>Accepts an optional <code>s</code></td>
</tr>
<tr>
<td><code>:</code></td>
<td>Matches exactly the <code>:</code> colon character</td>
</tr>
<tr>
<td><code>\/\/</code></td>
<td>Matches <code>//</code>. (The <code>\</code> backslash characters
are needed to indicate that the following <code>/</code> does not mark
the end of the Regular Expression)</td>
</tr>
<tr>
<td><code>localhost:3000\/</code></td>
<td>Matches the exact string <code>localhost:3000/</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td>Indicates the end of the Regular Expression</td>
</tr>
<tr>
<td><code>i</code></td>
<td>Indicates that the matches are case-insensitive (<code>HTTP</code>
will match as well as <code>http</code>)</td>
</tr>
</tbody>
</table>
<h2 id="setting-the-cookie-token-payload">Setting the cookie token
<code>payload</code></h2>
<p>You don’t want to lock the domain name to <code>localhost</code>, but
you don’t know in advance what domain and subdomain Render.com will
attribute to your Web Service. Here’s how you can edit your
<code>backend/serveCookie.js</code> script, so that it creates a payload
string similar to the Regular Expression shown above:</p>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * backend/serveCookie.js
 */

const { getToken } = require('./jwToken')

module.exports = (req, res, next) =&gt; {
  const { path } = req
  
  if ( path === "/" || path === "index.html" ) {
    // The request is for the  index.html page at the origin
    const host = req.headers.host // includes the port
    </i><b>const regex = `^https?:\/\/${host}/`

    console.log("regex:", regex)</b><i>
    
    // Create a token to record the origin that was requested...
    const pass = getToken(</i><b>regex</b><i>)
    // ... and serve it as session cookie.
    req.session.pass = pass

    // All API requests need a token with this origin as referer
  }

  next()
}</i></code></pre>
<h2 id="updating-jwtoken.js">Updating <code>jwToken.js</code></h2>
<p>Here’s how you can edit the <code>treatPass()</code> function of the
<code>jwToken.js</code> script, so that it <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp">creates
a Regular Expression</a> from the new <code>payload</code>, and uses
that to check the value of <code>referer</code>:</p>
<pre class="language-js line-numbers" data-start="59"><code class="language-js line-numbers"><i>function treatPass(error, payload) {
    console.log("payload:", payload)
    </i><b>const regex = new RegExp(payload, "i")</b><i>

    const sendHome = 
       error                // the JWT token was invalid
    </i><b>|| !regex.test(referer) // referer undefined or invalid
</b><i>
    if (sendHome) {
      // Ignore API request: respond with index.html file 
      return res.sendFile(INDEX_HTML)
    }

    proceed() // with API request
  }</i></code></pre>
<details class="note" open>
<summary>
sendHome is now simpler
</summary>
<p>The evaluation of <code>sendHome</code> is actually simpler, because
<a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test">the
<code>test</code> method of Regulars Expressions</a> returns
<code>false</code> if <code>referer</code> is not a string. As a result,
you know longer need to check if <code>referer</code> has a value or
not.</p>
</details>
<h2 id="one-last-tweak">One last tweak</h2>
<p>There is a small chance that visitor might try to connect to
<code>/ping</code> (or any other path) before ever making a request for
the <code>index.html</code> page. In this edge case, your server would
currently send back a 403 Unauthorized message. It would be cleaner to
simply redirect such a request to the root of the site, so that the home
page and its cookie is returned instead of an error.</p>
<p>You can edit the <code>if (!pass} ... else { }</code> statement as
follows, using the <a
href="https://expressjs.com/en/5x/api.html#res.redirect"><code>res.redirect()</code>
method</a>:</p>
<pre class="language-js line-numbers" data-start="44"><code class="language-js line-numbers">  <i>if (!pass) {
    if (is_dev) {
      console.log(`🤚DEV: PASS ${req.path} REQUEST FOR ${referer}`)

    } else {
      </i><b>// Ignore API request: serve home page + cookie instead
      return res.redirect("/")</b><i>
    }

    proceed()

  } else {
    jwt.verify(pass, JWT_SECRET, treatPass)
  }</i></code></pre>
<h2 id="pushing-changes-to-github">Pushing changes to GitHub</h2>
<ol type="1">
<li>In a Terminal window open on the <code>backend/</code> directory,
run:</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">git add . && git commit -m "Fix HTTPS issues"</code></pre>
<ol start="2" type="1">
<li>Run:</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">git push</code></pre>
<ol start="3" type="1">
<li>In the browser window where your Render.com dashboard is displayed,
click on the Manual Deploy button and choose Deploy Latest Commit.</li>
</ol>
<figure>
<img src="images/ManualDeploy.webp" alt="Manual deploy" />
<figcaption aria-hidden="true">Manual deploy</figcaption>
</figure>
<p>Render.com will run through it full install, build, deploy sequence,
and finally it will tell you again that <strong>Your service is live
🎉</strong>.</p>
<p>Test it. Click the link to your web service Check that it now behaves
exactly as you would expect.</p>
<details class="note" open>
<summary>
Heartbeat
</summary>
<p>You’ll notice that, every 5 seconds, the console in the Render.com
dashboard will print out:</p>
<pre class="language-bash"><code class="language-bash">regex: ^https?://vite-react-express.onrender.com/</code></pre>
<p>Render.com checks makes a request to your server every 5 seconds, to
check that it is still running. If it does not receive the expected
response, it will take action to restart your server. You can read more
about this <a
href="https://render.com/docs/deploys?_gl=1%2Ae0fqwh%2A_gcl_au%2AMzY2MjkwOTg1LjE3MzI5MjA2NzA.%2A_ga%2AODcyMjUwODE1LjE3MzI5MjA2NzA.%2A_ga_QK9L9QJC5N%2AMTczMzA0MDcxNC40LjEuMTczMzA0MjI1MC42MC4wLjA.#health-checks">here</a>.</p>
</details>
</section>
<!-- Loose Ends -->
<section id="loose-ends" aria-labelledby="loose-ends" data-item="Loose Ends">
<h2>
<a href="#loose-ends">Loose Ends</a>
</h2>
<p>Your proof-of-concept project is now working but there are still some
places that it could be tidied up. None of the changes mentioned here
will affect the way the workflow itself works. They are optional, but
recommended.</p>
<ol type="1">
<li>Stop using <code>console.log()</code></li>
<li>Use a production-strength logging system that generates log files
instead</li>
<li>Store the path that allows the frontend to connect with the backend
in a centralized place</li>
</ol>
<h2 id="remove-unneeded-console.logs">Remove unneeded
<code>console.log()</code>s</h2>
<p>The only <code>console.log()</code> statements that you really need
are:</p>
<ul>
<li>In <code>backend/server.js</code>
<ul>
<li><code>console.log("🤚USING CORS FOR DEVELOPMENT")</code></li>
<li><code>console.log(`Server listening at http://localhost:${PORT}`)</code></li>
</ul></li>
<li>In <code>backend/jwToken.js</code>
<ul>
<li><code>console.log(`🤚DEV: PASS ${req.path} REQUEST FOR ${referer}`)</code></li>
</ul></li>
</ul>
<p>You can comment out or delete all other occurrences.</p>
<h2 id="a-production-strength-logging-system">A production-strength
logging system</h2>
<p>When your server is deployed, you want to log all incoming requests
and errors in <code>.log</code> files that you can consult at any time.
This is not the focus of the current tutorial. For more details, you can
read <a
href="https://betterstack.com/community/guides/logging/how-to-install-setup-and-use-winston-and-morgan-to-log-node-js-applications/">this
article</a> by <a href="https://github.com/ayoisaiah">Ayooluwa
Isaiah</a>, and use <a
href="https://github.com/MERNCraft/backend-logging">this repo</a> as a
starting point for your explorations.</p>
<h2 id="centralize-storage-of-backend-url">Centralize storage of backend
URL</h2>
<p>Currently, only the <code>fetch()</code> method in the
<code>Ping.jsx</code> script makes a call to the backend API. In
development mode, it needs to connect to the server at the location you
set in <code>frontend/.env</code>. In production mode, it needs to use
connect to its own root.</p>
<p>In a real project, other scripts will need to know where to find the
server to connect to the backend API. One excellent way of doing this
with React is to use a <a
href="https://react.dev/learn/passing-data-deeply-with-context">Context</a>.
This means:</p>
<ul>
<li>Creating a special script to serve a Context and a Context
Provider</li>
<li>Wrapping any components that need access to the Contetxt in the
Provider</li>
<li>Importing the Context into any component that needs it</li>
<li>Using <code>useContext</code> to access the <code>value</code>
object provided by the Context</li>
</ul>
<h2 id="creating-an-api-context-and-provider">Creating an API Context
and Provider</h2>
<ol type="1">
<li>Create a new script at
<code>frontend/src/contexts/APIContext.jsx</code></li>
<li>Use the script shown below:</li>
</ol>
<pre class="language-js line-numbers"><code class="language-js line-numbers">/**
 * frontend/contexts/APIContext.jsx
 */

import React, { createContext } from 'react'

const ORIGIN = import.meta.env.VITE_ORIGIN
const dev = /^localhost:517\d$/.test(window.location.host)
const origin = dev ? ORIGIN : ""

export const APIContext = createContext()

export const APIProvider = ({ children }) =&gt; {
  return (
    &lt;APIContext.Provider
      value ={{
        origin
      }}
    &gt;
      {children}
    &lt;/APIContext.Provider&gt;
  )
}</code></pre>
<p>This exports two objects: <code>APIProvider</code> and API
<code>Context</code>. The <code>APIContext</code> provides a
<code>value</code> object where <code>origin</code> is set to the value
read in from <code>frontend/.env</code> during development or to
<code>""</code> in production.</p>
<ol start="3" type="1">
<li>Edit your script at <code>frontend/src/App.jsx</code> to match the
code below:</li>
</ol>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * frontend/src/App.jsx
 */
 
import {
  BrowserRouter as Router,
  Routes,
  Route
} from 'react-router-dom'
import './App.css'
import { Ping } from './components/Ping'
import { Page1 } from './pages/Page1'
import { Page2 } from './pages/Page2'
import { NotFound } from './pages/NotFound'
</i><b>import { APIProvider } from './contexts/APIContext'</b><i>

function App() {
  return (
    &lt;Router&gt;
      </i><b>&lt;APIProvider&gt;</b><i>
        &lt;Routes&gt;
          &lt;Route index element={&lt;Page1 /&gt;} /&gt;
          &lt;Route path="/page1" element={&lt;Page1 /&gt;} /&gt;
          &lt;Route path="/page2" element={&lt;Page2 /&gt;} /&gt;
          &lt;Route path="/ping" element={&lt;Ping /&gt;} /&gt;
          &lt;Route path="*" element={&lt;NotFound /&gt;} /&gt;
        &lt;/Routes&gt;
      </i><b>&lt;/APIProvider&gt;</b><i>
    &lt;/Router&gt;
  )
}

export default App</i></code></pre>
<p>Notice how this imports <code>APIProvider</code> and wraps it around
the <code>&lt;Routes&gt;</code> tag, so that all components, including
<code>Ping</code> will have access to the <code>APIContext</code> that
it provides.</p>
<ol start="4" type="1">
<li>Edit your <code>frontend/src/components/Ping.jsx</code> script so
that it matches Listing XXX below:</li>
</ol>
<pre class="language-js line-numbers"><code class="language-js line-numbers"><i>/**
 * frontend/src/components/Ping.jsx
 */

import React, { useState</i><b>, useContext</b><i> } from 'react'
import { APIContext } from '../contexts/APIContext'
<s>const ORIGIN = import.meta.env.VITE_ORIGIN
const dev = /^localhost:517\d$/.test(window.location.host)
const origin = dev ? ORIGIN : "" // "" in production mode</s>
const TAG_REGEX = /(&lt;.*?&gt;)|(&lt;\/.*?&gt;)/g

export const Ping = () =&gt; {
  </i><b>const { origin } = useContext(APIContext)</b><i>
  const [ response, setResponse ] = useState("")

  const getPing = () =&gt; {
    fetch(`${origin}/ping`)
      .then(incoming =&gt; incoming.text())
      // Always sanitize data from unreliable sources
      .then(text =&gt; text.replace(TAG_REGEX, ""))
      .then(text =&gt; setResponse(text))
      .catch(error =&gt; setResponse(error.message))
  }

  return (
    &lt;&gt;
      &lt;button
        onClick={getPing}
      &gt;
        GET /ping
      &lt;/button&gt;
      &lt;pre&gt;
        {response}
      &lt;/pre&gt;
    &lt;/&gt;
  )
}</i></code></pre>
<p>Notice that this:</p>
<ul>
<li>Imports <code>useContext</code> from <code>react</code></li>
<li>Imports <code>APIContext</code> from your new script</li>
<li>Uses <code>useContext(APIContext</code> to obtain the value of
<code>origin</code></li>
</ul>
<p>You can use the same technique in any other script that needs to call
the backend API.</p>
<ol start="5" type="1">
<li>In a Terminal that is open on your parent directory, run
<code>npm run publish</code></li>
<li>In a Terminal that is open on your <code>backend/</code> directory,
run:</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">git add . && git commit -m "Use Context for backend origin"</code></pre>
<ol start="7" type="1">
<li>Run:</li>
</ol>
<pre class="language-bash wrap"><code class="language-bash wrap">git push</code></pre>
<ol start="8" type="1">
<li>Visit your dashboard on Render.com</li>
<li>Click on the Manual Deploy button and choose
<code>Deploy Latest Commit</code></li>
</ol>
</section>
<!-- Conclusion -->
<section id="conclusion" aria-labelledby="conclusion" data-item="Conclusion">
<h2>
<a href="#conclusion">Conclusion</a>
</h2>
<p>The focus of this tutorial was to show you how to serve a React
frontend created with Vite through an Express backend, and ensure that
it would work safely when deployed to production.</p>
<p>The project in its current state is no more than a proof-of-concept.
All the work of building a useful site on these foundations is yet to
come.</p>
<p>You’ve explored the following techniques:</p>
<ul>
<li>How to set up your Vite React frontend and your Express backend in
sister directories in the same parent directory</li>
<li>How to create a <code>package.json</code> file with a
<code>"scripts"</code> block in the parent directory, so you can manage
both frontend and backend from the Terminal windows open on the same
directory</li>
<li>How to set up <code>npm</code> scripts along with a
<code>shell</code> script to build your Vite app automatically and copy
the files across to the <code>backend/public</code></li>
<li>How to get the backend Express server to serve the built React files
using <code>express.static()</code></li>
<li>How to get the backend Express server to respond to an API request
from the frontend</li>
<li>How to set up CORS to loosen security … in development mode
only</li>
<li>How to set up a JWT token and a cookie to limit access to the
backend API in production mode</li>
<li>How to ensure that the backend can run in production mode on any
port</li>
<li>How to manage client-side pages created using
<code>react-router-dom</code></li>
<li>How to deploy your project as a web service on Render.com</li>
</ul>
<p>But the medium is the message, so what else have you been
learning?</p>
<ul>
<li>How to make incremental changes and test after every change</li>
<li>When to use placeholders as scaffolding</li>
<li>How to split your code into self-contained modules</li>
<li>When to consult the documentation to master a new concept</li>
<li>How to check your understanding by rewriting code from first
principles</li>
<li>How to learn how to learn from error messages</li>
<li>How to identify potential problems in advance, and solve them at the
appropriate time</li>
<li>How to troubleshoot when results do not match assumptions</li>
<li>How to manage the differences between dev and prod environments</li>
<li>How to make your development environment compatible with the
production environment</li>
<li>How to automate your workflow</li>
</ul>
<p>Now you can use this project as a starting point for more ambitious
projects of your own.</p>
</section>
<!-- Introduction -->
<section id="Introduction" aria-labelledby="Introduction" data-item="Introduction">
<h2>
<a href="#Introduction">Introduction</a>
</h2>
<p><strong>Do you really need to host your frontend and your backend in
two different places?</strong></p>
<p>When creating a web site using the MERN stack (MongoDB, Express,
React and NodeJS), you might use:</p>
<ul>
<li><a href="https://vite.dev/">Vite</a> to develop your frontend</li>
<li><a href="https://expressjs.com/">Express</a> to develop your
backend</li>
<li>A hosting site such as <a href="https://render.com/">Render.com</a>
to host your frontend and backend separately.</li>
</ul>
<p>Having the frontend run from a different origin URL than the backend
means that you will have to deal with <a
href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS</a>
issues (Cross-Origin Resource Sharing).</p>
<p><strong>If you could use your Express backend to serve the files for
your React frontend, then:</strong></p>
<ol type="1">
<li><strong>CORS issues disappear</strong></li>
<li><strong>You only have to deploy a single Web Service on your hosting
site.</strong></li>
</ol>
<h2 id="what-happens-when-you-build-a-vite-react-site">What happens when
you build a Vite React site</h2>
<p>When a site built with Vite is deployed, the <code>build</code>
process actually reduces all your React code to three static files:</p>
<ul>
<li>index.html</li>
<li>assets/index_s0m35tuff.js</li>
<li>assets/index_m0reT3xt.css</li>
</ul>
<p>The <code>build</code> process creates these in a folder called
<code>dist/</code> and adds to this folder any additional files that you
may have included in the <code>public/</code> folder that you used
during development.</p>
<p>In other words, you can deploy your Vite React frontend as simply as
you would for a site built by hand with HTML, CSS and JavaScript.</p>
<h2 id="serving-a-static-react-site-with-express">Serving a static React
site with Express</h2>
<p>Your Express backend can <a
href="https://expressjs.com/en/starter/static-files.html">serve static
files from a chosen folder</a>. This means that you can use code as
simple as…</p>
<pre class="language-javascript"><code class="language-javascript">app.use(express.static('public'))</code></pre>
<p>… to serve your Vite React frontend. All you have to do is:</p>
<ul>
<li>Run <code>npm run build</code> in your Vite React director</li>
<li>Copy the files from the <code>dist/</code> folder into the
<code>public/</code> folder in your backend directory</li>
<li>Deploy your backend server.</li>
</ul>
<p>This tutorial will show you how to set up your development
environment to automate this process.</p>
<hr />
<details class="tip" open>
<summary>
In this tutorial, you will be learning how to…
</summary>
<ol type="1">
<li><a href="#barebones-frontend">Create a simple React frontend with
Vite</a></li>
<li><a href="#creating-pages-with-react-router-dom">Use React-Router-DOM
to create pages and internal links</a></li>
<li><a href="#simple-express-server">Create a simple Express
backend</a></li>
<li><a href="#accessing-the-api-from-the-frontend">Make API calls from
your frontend to your backend</a></li>
<li><a href="#server-differences">Ensure that the backend works nicely
with React-Router-DOM</a></li>
<li><a href="#special-treatment-for-index-html">Ensure that, in
production, the backend is accessible only to the official
frontend</a></li>
<li><a href="#writing-a-shell-script">Create scripts to automate the
deployment process</a></li>
<li><a href="#deploy-to-host">Deploy your site to Render.com</a></li>
</ol>
<p>Note that you won’t be seeing this topics in this order.</p>
</details>
<details class="note" open>
<summary>
Prerequisites
</summary>
<p>Before you start you should already have:</p>
<ul>
<li><a href="https://code.visualstudio.com/">A code editor, such as
Microsoft’s free Virtual Studio Code</a></li>
<li><a
href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm">Downloaded
and installed Node.js and NPM</a></li>
</ul>
<p>You should already be familiar with:</p>
<ul>
<li>JavaScript</li>
<li>Using <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promises</a>
and the <a
href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch"><code>fetch API</code></a>,
to retrieve data from a server.</li>
<li>Developing with <a href="https://react.dev/">React</a></li>
<li>Basic bash commands in a Terminal window</li>
<li>The most common <code>npm</code> commands</li>
</ul>
</details>
<details class="feedback" open>
<summary>
You can help improve this tutorial
</summary>
<p>If you have any difficulties with this tutorial, or any suggestions
on how to improve it, please <a
href="https://github.com/MERNCraft/express-react/issues/new">submit an
issue on GitHub</a>.</p>
</details>
<hr />
<details class="env" open>
<summary>
Development Environment
</summary>
<p>I work on MacOS Sonoma, using <a
href="https://code.visualstudio.com/">Microsoft’s Visual Studio Code</a>
as my code editor and <a
href="https://www.mozilla.org/en-US/firefox/new/">Mozilla Firefox</a> as
my default browser. If you are working on a different operating system,
using a different IDE or browser, the screenshots may not match exactly
what you see.</p>
<p>Any suggestions specific to VS Code will be shown in a field with a
pale blue background like this.</p>
</details>
</section>

<div class="spacer"></div>
<footer id="footer">
<button type="button" id="previous" disabled>&lt;</button>
<span id="previous-name"></span>
<span class="spacer"></span>
<button type="button" id="next">&gt;</button>
<span id="next-name"></span>
</footer>
</main>

<nav
id="menu"
class="open"
>
<div class="paging">
<label
title="Split into sections"
>
<img src="../public/svg/pages.svg" alt="pages">
<input
type="radio"
name="paging"
id="pages"
checked
>
</label>
<label
title="Show as a single page"
>
<img src="../public/svg/scroll.svg" alt="scroll">
<input
type="radio"
name="paging"
id="scroll"
>
</label>
</div>
<svg
id="menu-icon"
viewBox="0 0 100 100"
preserveAspectRatio="xMidYMid meet"
>
<g
class="menu"
stroke-width="20"
stroke-linecap="round"
>
<path
d="M5,20 L5,80 H95 L95,20 z"
fill="#0000"
stroke="none"
/>
<line
x1="15"
y1="20"
x2="85"
y2="20"
/>
<line
x1="15"
y1="50"
x2="85"
y2="50"
/>
<line
x1="15"
y1="80"
x2="85"
y2="80"
/>
</g>
</svg>

<ul id="menu-items">
</ul>

<div id="repo">
<a
href="https://github.com/MERNCraft/vite-react-express/issues/new"
>
Feedback
</a>

<a
class="repo"
href="https://github.com/MERNCraft/vite-react-express"
>
<img src="../public/svg/github.svg" alt="github logo">
<span>GitHub repository</span>
</a>
</div>
</nav>
</body>
</html>